// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messages.proto

#ifndef PROTOBUF_messages_2eproto__INCLUDED
#define PROTOBUF_messages_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace aesm {
namespace message {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_messages_2eproto();
void protobuf_AssignDesc_messages_2eproto();
void protobuf_ShutdownFile_messages_2eproto();

class Request;
class Request_InitQuoteRequest;
class Request_GetQuoteRequest;
class Request_GetLaunchTokenRequest;
class Request_ReportAttestationErrorRequest;
class Request_CreateSessionRequest;
class Request_InvokeServiceRequest;
class Request_ExchangeReportRequest;
class Request_CloseSessionRequest;
class Request_GetPsCapRequest;
class Request_GetWhiteListSizeRequest;
class Request_GetWhiteListRequest;
class Request_SGXGetExtendedEpidGroupIdRequest;
class Request_SGXSwitchExtendedEpidGroupRequest;
class Response;
class Response_InitQuoteResponse;
class Response_GetQuoteResponse;
class Response_GetLaunchTokenResponse;
class Response_ReportAttestationErrorResponse;
class Response_CreateSessionResponse;
class Response_InvokeServiceResponse;
class Response_ExchangeReportResponse;
class Response_CloseSessionResponse;
class Response_GetPsCapResponse;
class Response_GetWhiteListSizeResponse;
class Response_GetWhiteListResponse;
class Response_SGXGetExtendedEpidGroupIdResponse;
class Response_SGXSwitchExtendedEpidGroupResponse;

// ===================================================================

class Request_InitQuoteRequest : public ::google::protobuf::Message {
 public:
  Request_InitQuoteRequest();
  virtual ~Request_InitQuoteRequest();

  Request_InitQuoteRequest(const Request_InitQuoteRequest& from);

  inline Request_InitQuoteRequest& operator=(const Request_InitQuoteRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request_InitQuoteRequest& default_instance();

  void Swap(Request_InitQuoteRequest* other);

  // implements Message ----------------------------------------------

  Request_InitQuoteRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request_InitQuoteRequest& from);
  void MergeFrom(const Request_InitQuoteRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 timeout = 9;
  inline bool has_timeout() const;
  inline void clear_timeout();
  static const int kTimeoutFieldNumber = 9;
  inline ::google::protobuf::uint32 timeout() const;
  inline void set_timeout(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aesm.message.Request.InitQuoteRequest)
 private:
  inline void set_has_timeout();
  inline void clear_has_timeout();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 timeout_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Request_InitQuoteRequest* default_instance_;
};
// -------------------------------------------------------------------

class Request_GetQuoteRequest : public ::google::protobuf::Message {
 public:
  Request_GetQuoteRequest();
  virtual ~Request_GetQuoteRequest();

  Request_GetQuoteRequest(const Request_GetQuoteRequest& from);

  inline Request_GetQuoteRequest& operator=(const Request_GetQuoteRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request_GetQuoteRequest& default_instance();

  void Swap(Request_GetQuoteRequest* other);

  // implements Message ----------------------------------------------

  Request_GetQuoteRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request_GetQuoteRequest& from);
  void MergeFrom(const Request_GetQuoteRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes report = 1;
  inline bool has_report() const;
  inline void clear_report();
  static const int kReportFieldNumber = 1;
  inline const ::std::string& report() const;
  inline void set_report(const ::std::string& value);
  inline void set_report(const char* value);
  inline void set_report(const void* value, size_t size);
  inline ::std::string* mutable_report();
  inline ::std::string* release_report();
  inline void set_allocated_report(::std::string* report);

  // required uint32 quote_type = 2;
  inline bool has_quote_type() const;
  inline void clear_quote_type();
  static const int kQuoteTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 quote_type() const;
  inline void set_quote_type(::google::protobuf::uint32 value);

  // required bytes spid = 3;
  inline bool has_spid() const;
  inline void clear_spid();
  static const int kSpidFieldNumber = 3;
  inline const ::std::string& spid() const;
  inline void set_spid(const ::std::string& value);
  inline void set_spid(const char* value);
  inline void set_spid(const void* value, size_t size);
  inline ::std::string* mutable_spid();
  inline ::std::string* release_spid();
  inline void set_allocated_spid(::std::string* spid);

  // optional bytes nonce = 4;
  inline bool has_nonce() const;
  inline void clear_nonce();
  static const int kNonceFieldNumber = 4;
  inline const ::std::string& nonce() const;
  inline void set_nonce(const ::std::string& value);
  inline void set_nonce(const char* value);
  inline void set_nonce(const void* value, size_t size);
  inline ::std::string* mutable_nonce();
  inline ::std::string* release_nonce();
  inline void set_allocated_nonce(::std::string* nonce);

  // optional bytes sig_rl = 5;
  inline bool has_sig_rl() const;
  inline void clear_sig_rl();
  static const int kSigRlFieldNumber = 5;
  inline const ::std::string& sig_rl() const;
  inline void set_sig_rl(const ::std::string& value);
  inline void set_sig_rl(const char* value);
  inline void set_sig_rl(const void* value, size_t size);
  inline ::std::string* mutable_sig_rl();
  inline ::std::string* release_sig_rl();
  inline void set_allocated_sig_rl(::std::string* sig_rl);

  // required uint32 buf_size = 6;
  inline bool has_buf_size() const;
  inline void clear_buf_size();
  static const int kBufSizeFieldNumber = 6;
  inline ::google::protobuf::uint32 buf_size() const;
  inline void set_buf_size(::google::protobuf::uint32 value);

  // optional bool qe_report = 7;
  inline bool has_qe_report() const;
  inline void clear_qe_report();
  static const int kQeReportFieldNumber = 7;
  inline bool qe_report() const;
  inline void set_qe_report(bool value);

  // optional uint32 timeout = 9;
  inline bool has_timeout() const;
  inline void clear_timeout();
  static const int kTimeoutFieldNumber = 9;
  inline ::google::protobuf::uint32 timeout() const;
  inline void set_timeout(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aesm.message.Request.GetQuoteRequest)
 private:
  inline void set_has_report();
  inline void clear_has_report();
  inline void set_has_quote_type();
  inline void clear_has_quote_type();
  inline void set_has_spid();
  inline void clear_has_spid();
  inline void set_has_nonce();
  inline void clear_has_nonce();
  inline void set_has_sig_rl();
  inline void clear_has_sig_rl();
  inline void set_has_buf_size();
  inline void clear_has_buf_size();
  inline void set_has_qe_report();
  inline void clear_has_qe_report();
  inline void set_has_timeout();
  inline void clear_has_timeout();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* report_;
  ::std::string* spid_;
  ::std::string* nonce_;
  ::google::protobuf::uint32 quote_type_;
  ::google::protobuf::uint32 buf_size_;
  ::std::string* sig_rl_;
  bool qe_report_;
  ::google::protobuf::uint32 timeout_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Request_GetQuoteRequest* default_instance_;
};
// -------------------------------------------------------------------

class Request_GetLaunchTokenRequest : public ::google::protobuf::Message {
 public:
  Request_GetLaunchTokenRequest();
  virtual ~Request_GetLaunchTokenRequest();

  Request_GetLaunchTokenRequest(const Request_GetLaunchTokenRequest& from);

  inline Request_GetLaunchTokenRequest& operator=(const Request_GetLaunchTokenRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request_GetLaunchTokenRequest& default_instance();

  void Swap(Request_GetLaunchTokenRequest* other);

  // implements Message ----------------------------------------------

  Request_GetLaunchTokenRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request_GetLaunchTokenRequest& from);
  void MergeFrom(const Request_GetLaunchTokenRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes mr_enclave = 1;
  inline bool has_mr_enclave() const;
  inline void clear_mr_enclave();
  static const int kMrEnclaveFieldNumber = 1;
  inline const ::std::string& mr_enclave() const;
  inline void set_mr_enclave(const ::std::string& value);
  inline void set_mr_enclave(const char* value);
  inline void set_mr_enclave(const void* value, size_t size);
  inline ::std::string* mutable_mr_enclave();
  inline ::std::string* release_mr_enclave();
  inline void set_allocated_mr_enclave(::std::string* mr_enclave);

  // required bytes mr_signer = 2;
  inline bool has_mr_signer() const;
  inline void clear_mr_signer();
  static const int kMrSignerFieldNumber = 2;
  inline const ::std::string& mr_signer() const;
  inline void set_mr_signer(const ::std::string& value);
  inline void set_mr_signer(const char* value);
  inline void set_mr_signer(const void* value, size_t size);
  inline ::std::string* mutable_mr_signer();
  inline ::std::string* release_mr_signer();
  inline void set_allocated_mr_signer(::std::string* mr_signer);

  // required bytes se_attributes = 3;
  inline bool has_se_attributes() const;
  inline void clear_se_attributes();
  static const int kSeAttributesFieldNumber = 3;
  inline const ::std::string& se_attributes() const;
  inline void set_se_attributes(const ::std::string& value);
  inline void set_se_attributes(const char* value);
  inline void set_se_attributes(const void* value, size_t size);
  inline ::std::string* mutable_se_attributes();
  inline ::std::string* release_se_attributes();
  inline void set_allocated_se_attributes(::std::string* se_attributes);

  // optional uint32 timeout = 9;
  inline bool has_timeout() const;
  inline void clear_timeout();
  static const int kTimeoutFieldNumber = 9;
  inline ::google::protobuf::uint32 timeout() const;
  inline void set_timeout(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aesm.message.Request.GetLaunchTokenRequest)
 private:
  inline void set_has_mr_enclave();
  inline void clear_has_mr_enclave();
  inline void set_has_mr_signer();
  inline void clear_has_mr_signer();
  inline void set_has_se_attributes();
  inline void clear_has_se_attributes();
  inline void set_has_timeout();
  inline void clear_has_timeout();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* mr_enclave_;
  ::std::string* mr_signer_;
  ::std::string* se_attributes_;
  ::google::protobuf::uint32 timeout_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Request_GetLaunchTokenRequest* default_instance_;
};
// -------------------------------------------------------------------

class Request_ReportAttestationErrorRequest : public ::google::protobuf::Message {
 public:
  Request_ReportAttestationErrorRequest();
  virtual ~Request_ReportAttestationErrorRequest();

  Request_ReportAttestationErrorRequest(const Request_ReportAttestationErrorRequest& from);

  inline Request_ReportAttestationErrorRequest& operator=(const Request_ReportAttestationErrorRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request_ReportAttestationErrorRequest& default_instance();

  void Swap(Request_ReportAttestationErrorRequest* other);

  // implements Message ----------------------------------------------

  Request_ReportAttestationErrorRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request_ReportAttestationErrorRequest& from);
  void MergeFrom(const Request_ReportAttestationErrorRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes platform_info = 1;
  inline bool has_platform_info() const;
  inline void clear_platform_info();
  static const int kPlatformInfoFieldNumber = 1;
  inline const ::std::string& platform_info() const;
  inline void set_platform_info(const ::std::string& value);
  inline void set_platform_info(const char* value);
  inline void set_platform_info(const void* value, size_t size);
  inline ::std::string* mutable_platform_info();
  inline ::std::string* release_platform_info();
  inline void set_allocated_platform_info(::std::string* platform_info);

  // required uint32 attestation_error_code = 2;
  inline bool has_attestation_error_code() const;
  inline void clear_attestation_error_code();
  static const int kAttestationErrorCodeFieldNumber = 2;
  inline ::google::protobuf::uint32 attestation_error_code() const;
  inline void set_attestation_error_code(::google::protobuf::uint32 value);

  // required uint32 update_info_size = 3;
  inline bool has_update_info_size() const;
  inline void clear_update_info_size();
  static const int kUpdateInfoSizeFieldNumber = 3;
  inline ::google::protobuf::uint32 update_info_size() const;
  inline void set_update_info_size(::google::protobuf::uint32 value);

  // optional uint32 timeout = 9;
  inline bool has_timeout() const;
  inline void clear_timeout();
  static const int kTimeoutFieldNumber = 9;
  inline ::google::protobuf::uint32 timeout() const;
  inline void set_timeout(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aesm.message.Request.ReportAttestationErrorRequest)
 private:
  inline void set_has_platform_info();
  inline void clear_has_platform_info();
  inline void set_has_attestation_error_code();
  inline void clear_has_attestation_error_code();
  inline void set_has_update_info_size();
  inline void clear_has_update_info_size();
  inline void set_has_timeout();
  inline void clear_has_timeout();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* platform_info_;
  ::google::protobuf::uint32 attestation_error_code_;
  ::google::protobuf::uint32 update_info_size_;
  ::google::protobuf::uint32 timeout_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Request_ReportAttestationErrorRequest* default_instance_;
};
// -------------------------------------------------------------------

class Request_CreateSessionRequest : public ::google::protobuf::Message {
 public:
  Request_CreateSessionRequest();
  virtual ~Request_CreateSessionRequest();

  Request_CreateSessionRequest(const Request_CreateSessionRequest& from);

  inline Request_CreateSessionRequest& operator=(const Request_CreateSessionRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request_CreateSessionRequest& default_instance();

  void Swap(Request_CreateSessionRequest* other);

  // implements Message ----------------------------------------------

  Request_CreateSessionRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request_CreateSessionRequest& from);
  void MergeFrom(const Request_CreateSessionRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 dh_msg1_size = 1;
  inline bool has_dh_msg1_size() const;
  inline void clear_dh_msg1_size();
  static const int kDhMsg1SizeFieldNumber = 1;
  inline ::google::protobuf::uint32 dh_msg1_size() const;
  inline void set_dh_msg1_size(::google::protobuf::uint32 value);

  // optional uint32 timeout = 9;
  inline bool has_timeout() const;
  inline void clear_timeout();
  static const int kTimeoutFieldNumber = 9;
  inline ::google::protobuf::uint32 timeout() const;
  inline void set_timeout(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aesm.message.Request.CreateSessionRequest)
 private:
  inline void set_has_dh_msg1_size();
  inline void clear_has_dh_msg1_size();
  inline void set_has_timeout();
  inline void clear_has_timeout();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 dh_msg1_size_;
  ::google::protobuf::uint32 timeout_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Request_CreateSessionRequest* default_instance_;
};
// -------------------------------------------------------------------

class Request_InvokeServiceRequest : public ::google::protobuf::Message {
 public:
  Request_InvokeServiceRequest();
  virtual ~Request_InvokeServiceRequest();

  Request_InvokeServiceRequest(const Request_InvokeServiceRequest& from);

  inline Request_InvokeServiceRequest& operator=(const Request_InvokeServiceRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request_InvokeServiceRequest& default_instance();

  void Swap(Request_InvokeServiceRequest* other);

  // implements Message ----------------------------------------------

  Request_InvokeServiceRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request_InvokeServiceRequest& from);
  void MergeFrom(const Request_InvokeServiceRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes pse_message = 1;
  inline bool has_pse_message() const;
  inline void clear_pse_message();
  static const int kPseMessageFieldNumber = 1;
  inline const ::std::string& pse_message() const;
  inline void set_pse_message(const ::std::string& value);
  inline void set_pse_message(const char* value);
  inline void set_pse_message(const void* value, size_t size);
  inline ::std::string* mutable_pse_message();
  inline ::std::string* release_pse_message();
  inline void set_allocated_pse_message(::std::string* pse_message);

  // required uint32 pse_resp_size = 2;
  inline bool has_pse_resp_size() const;
  inline void clear_pse_resp_size();
  static const int kPseRespSizeFieldNumber = 2;
  inline ::google::protobuf::uint32 pse_resp_size() const;
  inline void set_pse_resp_size(::google::protobuf::uint32 value);

  // optional uint32 timeout = 9;
  inline bool has_timeout() const;
  inline void clear_timeout();
  static const int kTimeoutFieldNumber = 9;
  inline ::google::protobuf::uint32 timeout() const;
  inline void set_timeout(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aesm.message.Request.InvokeServiceRequest)
 private:
  inline void set_has_pse_message();
  inline void clear_has_pse_message();
  inline void set_has_pse_resp_size();
  inline void clear_has_pse_resp_size();
  inline void set_has_timeout();
  inline void clear_has_timeout();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* pse_message_;
  ::google::protobuf::uint32 pse_resp_size_;
  ::google::protobuf::uint32 timeout_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Request_InvokeServiceRequest* default_instance_;
};
// -------------------------------------------------------------------

class Request_ExchangeReportRequest : public ::google::protobuf::Message {
 public:
  Request_ExchangeReportRequest();
  virtual ~Request_ExchangeReportRequest();

  Request_ExchangeReportRequest(const Request_ExchangeReportRequest& from);

  inline Request_ExchangeReportRequest& operator=(const Request_ExchangeReportRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request_ExchangeReportRequest& default_instance();

  void Swap(Request_ExchangeReportRequest* other);

  // implements Message ----------------------------------------------

  Request_ExchangeReportRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request_ExchangeReportRequest& from);
  void MergeFrom(const Request_ExchangeReportRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 session_id = 1;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 1;
  inline ::google::protobuf::uint32 session_id() const;
  inline void set_session_id(::google::protobuf::uint32 value);

  // required bytes se_dh_msg2 = 2;
  inline bool has_se_dh_msg2() const;
  inline void clear_se_dh_msg2();
  static const int kSeDhMsg2FieldNumber = 2;
  inline const ::std::string& se_dh_msg2() const;
  inline void set_se_dh_msg2(const ::std::string& value);
  inline void set_se_dh_msg2(const char* value);
  inline void set_se_dh_msg2(const void* value, size_t size);
  inline ::std::string* mutable_se_dh_msg2();
  inline ::std::string* release_se_dh_msg2();
  inline void set_allocated_se_dh_msg2(::std::string* se_dh_msg2);

  // required uint32 se_dh_msg3_size = 3;
  inline bool has_se_dh_msg3_size() const;
  inline void clear_se_dh_msg3_size();
  static const int kSeDhMsg3SizeFieldNumber = 3;
  inline ::google::protobuf::uint32 se_dh_msg3_size() const;
  inline void set_se_dh_msg3_size(::google::protobuf::uint32 value);

  // optional uint32 timeout = 9;
  inline bool has_timeout() const;
  inline void clear_timeout();
  static const int kTimeoutFieldNumber = 9;
  inline ::google::protobuf::uint32 timeout() const;
  inline void set_timeout(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aesm.message.Request.ExchangeReportRequest)
 private:
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_se_dh_msg2();
  inline void clear_has_se_dh_msg2();
  inline void set_has_se_dh_msg3_size();
  inline void clear_has_se_dh_msg3_size();
  inline void set_has_timeout();
  inline void clear_has_timeout();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* se_dh_msg2_;
  ::google::protobuf::uint32 session_id_;
  ::google::protobuf::uint32 se_dh_msg3_size_;
  ::google::protobuf::uint32 timeout_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Request_ExchangeReportRequest* default_instance_;
};
// -------------------------------------------------------------------

class Request_CloseSessionRequest : public ::google::protobuf::Message {
 public:
  Request_CloseSessionRequest();
  virtual ~Request_CloseSessionRequest();

  Request_CloseSessionRequest(const Request_CloseSessionRequest& from);

  inline Request_CloseSessionRequest& operator=(const Request_CloseSessionRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request_CloseSessionRequest& default_instance();

  void Swap(Request_CloseSessionRequest* other);

  // implements Message ----------------------------------------------

  Request_CloseSessionRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request_CloseSessionRequest& from);
  void MergeFrom(const Request_CloseSessionRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 session_id = 1;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 1;
  inline ::google::protobuf::uint32 session_id() const;
  inline void set_session_id(::google::protobuf::uint32 value);

  // optional uint32 timeout = 9;
  inline bool has_timeout() const;
  inline void clear_timeout();
  static const int kTimeoutFieldNumber = 9;
  inline ::google::protobuf::uint32 timeout() const;
  inline void set_timeout(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aesm.message.Request.CloseSessionRequest)
 private:
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_timeout();
  inline void clear_has_timeout();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 session_id_;
  ::google::protobuf::uint32 timeout_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Request_CloseSessionRequest* default_instance_;
};
// -------------------------------------------------------------------

class Request_GetPsCapRequest : public ::google::protobuf::Message {
 public:
  Request_GetPsCapRequest();
  virtual ~Request_GetPsCapRequest();

  Request_GetPsCapRequest(const Request_GetPsCapRequest& from);

  inline Request_GetPsCapRequest& operator=(const Request_GetPsCapRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request_GetPsCapRequest& default_instance();

  void Swap(Request_GetPsCapRequest* other);

  // implements Message ----------------------------------------------

  Request_GetPsCapRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request_GetPsCapRequest& from);
  void MergeFrom(const Request_GetPsCapRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 timeout = 9;
  inline bool has_timeout() const;
  inline void clear_timeout();
  static const int kTimeoutFieldNumber = 9;
  inline ::google::protobuf::uint32 timeout() const;
  inline void set_timeout(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aesm.message.Request.GetPsCapRequest)
 private:
  inline void set_has_timeout();
  inline void clear_has_timeout();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 timeout_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Request_GetPsCapRequest* default_instance_;
};
// -------------------------------------------------------------------

class Request_GetWhiteListSizeRequest : public ::google::protobuf::Message {
 public:
  Request_GetWhiteListSizeRequest();
  virtual ~Request_GetWhiteListSizeRequest();

  Request_GetWhiteListSizeRequest(const Request_GetWhiteListSizeRequest& from);

  inline Request_GetWhiteListSizeRequest& operator=(const Request_GetWhiteListSizeRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request_GetWhiteListSizeRequest& default_instance();

  void Swap(Request_GetWhiteListSizeRequest* other);

  // implements Message ----------------------------------------------

  Request_GetWhiteListSizeRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request_GetWhiteListSizeRequest& from);
  void MergeFrom(const Request_GetWhiteListSizeRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 timeout = 9;
  inline bool has_timeout() const;
  inline void clear_timeout();
  static const int kTimeoutFieldNumber = 9;
  inline ::google::protobuf::uint32 timeout() const;
  inline void set_timeout(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aesm.message.Request.GetWhiteListSizeRequest)
 private:
  inline void set_has_timeout();
  inline void clear_has_timeout();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 timeout_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Request_GetWhiteListSizeRequest* default_instance_;
};
// -------------------------------------------------------------------

class Request_GetWhiteListRequest : public ::google::protobuf::Message {
 public:
  Request_GetWhiteListRequest();
  virtual ~Request_GetWhiteListRequest();

  Request_GetWhiteListRequest(const Request_GetWhiteListRequest& from);

  inline Request_GetWhiteListRequest& operator=(const Request_GetWhiteListRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request_GetWhiteListRequest& default_instance();

  void Swap(Request_GetWhiteListRequest* other);

  // implements Message ----------------------------------------------

  Request_GetWhiteListRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request_GetWhiteListRequest& from);
  void MergeFrom(const Request_GetWhiteListRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 white_list_size = 1;
  inline bool has_white_list_size() const;
  inline void clear_white_list_size();
  static const int kWhiteListSizeFieldNumber = 1;
  inline ::google::protobuf::uint32 white_list_size() const;
  inline void set_white_list_size(::google::protobuf::uint32 value);

  // optional uint32 timeout = 9;
  inline bool has_timeout() const;
  inline void clear_timeout();
  static const int kTimeoutFieldNumber = 9;
  inline ::google::protobuf::uint32 timeout() const;
  inline void set_timeout(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aesm.message.Request.GetWhiteListRequest)
 private:
  inline void set_has_white_list_size();
  inline void clear_has_white_list_size();
  inline void set_has_timeout();
  inline void clear_has_timeout();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 white_list_size_;
  ::google::protobuf::uint32 timeout_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Request_GetWhiteListRequest* default_instance_;
};
// -------------------------------------------------------------------

class Request_SGXGetExtendedEpidGroupIdRequest : public ::google::protobuf::Message {
 public:
  Request_SGXGetExtendedEpidGroupIdRequest();
  virtual ~Request_SGXGetExtendedEpidGroupIdRequest();

  Request_SGXGetExtendedEpidGroupIdRequest(const Request_SGXGetExtendedEpidGroupIdRequest& from);

  inline Request_SGXGetExtendedEpidGroupIdRequest& operator=(const Request_SGXGetExtendedEpidGroupIdRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request_SGXGetExtendedEpidGroupIdRequest& default_instance();

  void Swap(Request_SGXGetExtendedEpidGroupIdRequest* other);

  // implements Message ----------------------------------------------

  Request_SGXGetExtendedEpidGroupIdRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request_SGXGetExtendedEpidGroupIdRequest& from);
  void MergeFrom(const Request_SGXGetExtendedEpidGroupIdRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 timeout = 9;
  inline bool has_timeout() const;
  inline void clear_timeout();
  static const int kTimeoutFieldNumber = 9;
  inline ::google::protobuf::uint32 timeout() const;
  inline void set_timeout(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aesm.message.Request.SGXGetExtendedEpidGroupIdRequest)
 private:
  inline void set_has_timeout();
  inline void clear_has_timeout();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 timeout_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Request_SGXGetExtendedEpidGroupIdRequest* default_instance_;
};
// -------------------------------------------------------------------

class Request_SGXSwitchExtendedEpidGroupRequest : public ::google::protobuf::Message {
 public:
  Request_SGXSwitchExtendedEpidGroupRequest();
  virtual ~Request_SGXSwitchExtendedEpidGroupRequest();

  Request_SGXSwitchExtendedEpidGroupRequest(const Request_SGXSwitchExtendedEpidGroupRequest& from);

  inline Request_SGXSwitchExtendedEpidGroupRequest& operator=(const Request_SGXSwitchExtendedEpidGroupRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request_SGXSwitchExtendedEpidGroupRequest& default_instance();

  void Swap(Request_SGXSwitchExtendedEpidGroupRequest* other);

  // implements Message ----------------------------------------------

  Request_SGXSwitchExtendedEpidGroupRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request_SGXSwitchExtendedEpidGroupRequest& from);
  void MergeFrom(const Request_SGXSwitchExtendedEpidGroupRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 x_group_id = 1;
  inline bool has_x_group_id() const;
  inline void clear_x_group_id();
  static const int kXGroupIdFieldNumber = 1;
  inline ::google::protobuf::uint32 x_group_id() const;
  inline void set_x_group_id(::google::protobuf::uint32 value);

  // optional uint32 timeout = 9;
  inline bool has_timeout() const;
  inline void clear_timeout();
  static const int kTimeoutFieldNumber = 9;
  inline ::google::protobuf::uint32 timeout() const;
  inline void set_timeout(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aesm.message.Request.SGXSwitchExtendedEpidGroupRequest)
 private:
  inline void set_has_x_group_id();
  inline void clear_has_x_group_id();
  inline void set_has_timeout();
  inline void clear_has_timeout();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 x_group_id_;
  ::google::protobuf::uint32 timeout_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Request_SGXSwitchExtendedEpidGroupRequest* default_instance_;
};
// -------------------------------------------------------------------

class Request : public ::google::protobuf::Message {
 public:
  Request();
  virtual ~Request();

  Request(const Request& from);

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request& default_instance();

  void Swap(Request* other);

  // implements Message ----------------------------------------------

  Request* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request& from);
  void MergeFrom(const Request& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Request_InitQuoteRequest InitQuoteRequest;
  typedef Request_GetQuoteRequest GetQuoteRequest;
  typedef Request_GetLaunchTokenRequest GetLaunchTokenRequest;
  typedef Request_ReportAttestationErrorRequest ReportAttestationErrorRequest;
  typedef Request_CreateSessionRequest CreateSessionRequest;
  typedef Request_InvokeServiceRequest InvokeServiceRequest;
  typedef Request_ExchangeReportRequest ExchangeReportRequest;
  typedef Request_CloseSessionRequest CloseSessionRequest;
  typedef Request_GetPsCapRequest GetPsCapRequest;
  typedef Request_GetWhiteListSizeRequest GetWhiteListSizeRequest;
  typedef Request_GetWhiteListRequest GetWhiteListRequest;
  typedef Request_SGXGetExtendedEpidGroupIdRequest SGXGetExtendedEpidGroupIdRequest;
  typedef Request_SGXSwitchExtendedEpidGroupRequest SGXSwitchExtendedEpidGroupRequest;

  // accessors -------------------------------------------------------

  // optional .aesm.message.Request.InitQuoteRequest initQuoteReq = 1;
  inline bool has_initquotereq() const;
  inline void clear_initquotereq();
  static const int kInitQuoteReqFieldNumber = 1;
  inline const ::aesm::message::Request_InitQuoteRequest& initquotereq() const;
  inline ::aesm::message::Request_InitQuoteRequest* mutable_initquotereq();
  inline ::aesm::message::Request_InitQuoteRequest* release_initquotereq();
  inline void set_allocated_initquotereq(::aesm::message::Request_InitQuoteRequest* initquotereq);

  // optional .aesm.message.Request.GetQuoteRequest getQuoteReq = 2;
  inline bool has_getquotereq() const;
  inline void clear_getquotereq();
  static const int kGetQuoteReqFieldNumber = 2;
  inline const ::aesm::message::Request_GetQuoteRequest& getquotereq() const;
  inline ::aesm::message::Request_GetQuoteRequest* mutable_getquotereq();
  inline ::aesm::message::Request_GetQuoteRequest* release_getquotereq();
  inline void set_allocated_getquotereq(::aesm::message::Request_GetQuoteRequest* getquotereq);

  // optional .aesm.message.Request.GetLaunchTokenRequest getLicTokenReq = 3;
  inline bool has_getlictokenreq() const;
  inline void clear_getlictokenreq();
  static const int kGetLicTokenReqFieldNumber = 3;
  inline const ::aesm::message::Request_GetLaunchTokenRequest& getlictokenreq() const;
  inline ::aesm::message::Request_GetLaunchTokenRequest* mutable_getlictokenreq();
  inline ::aesm::message::Request_GetLaunchTokenRequest* release_getlictokenreq();
  inline void set_allocated_getlictokenreq(::aesm::message::Request_GetLaunchTokenRequest* getlictokenreq);

  // optional .aesm.message.Request.ReportAttestationErrorRequest reportErrReq = 4;
  inline bool has_reporterrreq() const;
  inline void clear_reporterrreq();
  static const int kReportErrReqFieldNumber = 4;
  inline const ::aesm::message::Request_ReportAttestationErrorRequest& reporterrreq() const;
  inline ::aesm::message::Request_ReportAttestationErrorRequest* mutable_reporterrreq();
  inline ::aesm::message::Request_ReportAttestationErrorRequest* release_reporterrreq();
  inline void set_allocated_reporterrreq(::aesm::message::Request_ReportAttestationErrorRequest* reporterrreq);

  // optional .aesm.message.Request.CreateSessionRequest createSessionReq = 5;
  inline bool has_createsessionreq() const;
  inline void clear_createsessionreq();
  static const int kCreateSessionReqFieldNumber = 5;
  inline const ::aesm::message::Request_CreateSessionRequest& createsessionreq() const;
  inline ::aesm::message::Request_CreateSessionRequest* mutable_createsessionreq();
  inline ::aesm::message::Request_CreateSessionRequest* release_createsessionreq();
  inline void set_allocated_createsessionreq(::aesm::message::Request_CreateSessionRequest* createsessionreq);

  // optional .aesm.message.Request.InvokeServiceRequest invokeServiceReq = 6;
  inline bool has_invokeservicereq() const;
  inline void clear_invokeservicereq();
  static const int kInvokeServiceReqFieldNumber = 6;
  inline const ::aesm::message::Request_InvokeServiceRequest& invokeservicereq() const;
  inline ::aesm::message::Request_InvokeServiceRequest* mutable_invokeservicereq();
  inline ::aesm::message::Request_InvokeServiceRequest* release_invokeservicereq();
  inline void set_allocated_invokeservicereq(::aesm::message::Request_InvokeServiceRequest* invokeservicereq);

  // optional .aesm.message.Request.ExchangeReportRequest exchangeReportReq = 7;
  inline bool has_exchangereportreq() const;
  inline void clear_exchangereportreq();
  static const int kExchangeReportReqFieldNumber = 7;
  inline const ::aesm::message::Request_ExchangeReportRequest& exchangereportreq() const;
  inline ::aesm::message::Request_ExchangeReportRequest* mutable_exchangereportreq();
  inline ::aesm::message::Request_ExchangeReportRequest* release_exchangereportreq();
  inline void set_allocated_exchangereportreq(::aesm::message::Request_ExchangeReportRequest* exchangereportreq);

  // optional .aesm.message.Request.CloseSessionRequest closeSessionReq = 8;
  inline bool has_closesessionreq() const;
  inline void clear_closesessionreq();
  static const int kCloseSessionReqFieldNumber = 8;
  inline const ::aesm::message::Request_CloseSessionRequest& closesessionreq() const;
  inline ::aesm::message::Request_CloseSessionRequest* mutable_closesessionreq();
  inline ::aesm::message::Request_CloseSessionRequest* release_closesessionreq();
  inline void set_allocated_closesessionreq(::aesm::message::Request_CloseSessionRequest* closesessionreq);

  // optional .aesm.message.Request.GetPsCapRequest getPsCapReq = 9;
  inline bool has_getpscapreq() const;
  inline void clear_getpscapreq();
  static const int kGetPsCapReqFieldNumber = 9;
  inline const ::aesm::message::Request_GetPsCapRequest& getpscapreq() const;
  inline ::aesm::message::Request_GetPsCapRequest* mutable_getpscapreq();
  inline ::aesm::message::Request_GetPsCapRequest* release_getpscapreq();
  inline void set_allocated_getpscapreq(::aesm::message::Request_GetPsCapRequest* getpscapreq);

  // optional .aesm.message.Request.GetWhiteListSizeRequest getWhiteListSizeReq = 10;
  inline bool has_getwhitelistsizereq() const;
  inline void clear_getwhitelistsizereq();
  static const int kGetWhiteListSizeReqFieldNumber = 10;
  inline const ::aesm::message::Request_GetWhiteListSizeRequest& getwhitelistsizereq() const;
  inline ::aesm::message::Request_GetWhiteListSizeRequest* mutable_getwhitelistsizereq();
  inline ::aesm::message::Request_GetWhiteListSizeRequest* release_getwhitelistsizereq();
  inline void set_allocated_getwhitelistsizereq(::aesm::message::Request_GetWhiteListSizeRequest* getwhitelistsizereq);

  // optional .aesm.message.Request.GetWhiteListRequest getWhiteListReq = 11;
  inline bool has_getwhitelistreq() const;
  inline void clear_getwhitelistreq();
  static const int kGetWhiteListReqFieldNumber = 11;
  inline const ::aesm::message::Request_GetWhiteListRequest& getwhitelistreq() const;
  inline ::aesm::message::Request_GetWhiteListRequest* mutable_getwhitelistreq();
  inline ::aesm::message::Request_GetWhiteListRequest* release_getwhitelistreq();
  inline void set_allocated_getwhitelistreq(::aesm::message::Request_GetWhiteListRequest* getwhitelistreq);

  // optional .aesm.message.Request.SGXGetExtendedEpidGroupIdRequest sgxGetExtendedEpidGroupIdReq = 12;
  inline bool has_sgxgetextendedepidgroupidreq() const;
  inline void clear_sgxgetextendedepidgroupidreq();
  static const int kSgxGetExtendedEpidGroupIdReqFieldNumber = 12;
  inline const ::aesm::message::Request_SGXGetExtendedEpidGroupIdRequest& sgxgetextendedepidgroupidreq() const;
  inline ::aesm::message::Request_SGXGetExtendedEpidGroupIdRequest* mutable_sgxgetextendedepidgroupidreq();
  inline ::aesm::message::Request_SGXGetExtendedEpidGroupIdRequest* release_sgxgetextendedepidgroupidreq();
  inline void set_allocated_sgxgetextendedepidgroupidreq(::aesm::message::Request_SGXGetExtendedEpidGroupIdRequest* sgxgetextendedepidgroupidreq);

  // optional .aesm.message.Request.SGXSwitchExtendedEpidGroupRequest sgxSwitchExtendedEpidGroupReq = 13;
  inline bool has_sgxswitchextendedepidgroupreq() const;
  inline void clear_sgxswitchextendedepidgroupreq();
  static const int kSgxSwitchExtendedEpidGroupReqFieldNumber = 13;
  inline const ::aesm::message::Request_SGXSwitchExtendedEpidGroupRequest& sgxswitchextendedepidgroupreq() const;
  inline ::aesm::message::Request_SGXSwitchExtendedEpidGroupRequest* mutable_sgxswitchextendedepidgroupreq();
  inline ::aesm::message::Request_SGXSwitchExtendedEpidGroupRequest* release_sgxswitchextendedepidgroupreq();
  inline void set_allocated_sgxswitchextendedepidgroupreq(::aesm::message::Request_SGXSwitchExtendedEpidGroupRequest* sgxswitchextendedepidgroupreq);

  // @@protoc_insertion_point(class_scope:aesm.message.Request)
 private:
  inline void set_has_initquotereq();
  inline void clear_has_initquotereq();
  inline void set_has_getquotereq();
  inline void clear_has_getquotereq();
  inline void set_has_getlictokenreq();
  inline void clear_has_getlictokenreq();
  inline void set_has_reporterrreq();
  inline void clear_has_reporterrreq();
  inline void set_has_createsessionreq();
  inline void clear_has_createsessionreq();
  inline void set_has_invokeservicereq();
  inline void clear_has_invokeservicereq();
  inline void set_has_exchangereportreq();
  inline void clear_has_exchangereportreq();
  inline void set_has_closesessionreq();
  inline void clear_has_closesessionreq();
  inline void set_has_getpscapreq();
  inline void clear_has_getpscapreq();
  inline void set_has_getwhitelistsizereq();
  inline void clear_has_getwhitelistsizereq();
  inline void set_has_getwhitelistreq();
  inline void clear_has_getwhitelistreq();
  inline void set_has_sgxgetextendedepidgroupidreq();
  inline void clear_has_sgxgetextendedepidgroupidreq();
  inline void set_has_sgxswitchextendedepidgroupreq();
  inline void clear_has_sgxswitchextendedepidgroupreq();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::aesm::message::Request_InitQuoteRequest* initquotereq_;
  ::aesm::message::Request_GetQuoteRequest* getquotereq_;
  ::aesm::message::Request_GetLaunchTokenRequest* getlictokenreq_;
  ::aesm::message::Request_ReportAttestationErrorRequest* reporterrreq_;
  ::aesm::message::Request_CreateSessionRequest* createsessionreq_;
  ::aesm::message::Request_InvokeServiceRequest* invokeservicereq_;
  ::aesm::message::Request_ExchangeReportRequest* exchangereportreq_;
  ::aesm::message::Request_CloseSessionRequest* closesessionreq_;
  ::aesm::message::Request_GetPsCapRequest* getpscapreq_;
  ::aesm::message::Request_GetWhiteListSizeRequest* getwhitelistsizereq_;
  ::aesm::message::Request_GetWhiteListRequest* getwhitelistreq_;
  ::aesm::message::Request_SGXGetExtendedEpidGroupIdRequest* sgxgetextendedepidgroupidreq_;
  ::aesm::message::Request_SGXSwitchExtendedEpidGroupRequest* sgxswitchextendedepidgroupreq_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Request* default_instance_;
};
// -------------------------------------------------------------------

class Response_InitQuoteResponse : public ::google::protobuf::Message {
 public:
  Response_InitQuoteResponse();
  virtual ~Response_InitQuoteResponse();

  Response_InitQuoteResponse(const Response_InitQuoteResponse& from);

  inline Response_InitQuoteResponse& operator=(const Response_InitQuoteResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response_InitQuoteResponse& default_instance();

  void Swap(Response_InitQuoteResponse* other);

  // implements Message ----------------------------------------------

  Response_InitQuoteResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Response_InitQuoteResponse& from);
  void MergeFrom(const Response_InitQuoteResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 errorCode = 1 [default = 1];
  inline bool has_errorcode() const;
  inline void clear_errorcode();
  static const int kErrorCodeFieldNumber = 1;
  inline ::google::protobuf::uint32 errorcode() const;
  inline void set_errorcode(::google::protobuf::uint32 value);

  // optional bytes targetInfo = 2;
  inline bool has_targetinfo() const;
  inline void clear_targetinfo();
  static const int kTargetInfoFieldNumber = 2;
  inline const ::std::string& targetinfo() const;
  inline void set_targetinfo(const ::std::string& value);
  inline void set_targetinfo(const char* value);
  inline void set_targetinfo(const void* value, size_t size);
  inline ::std::string* mutable_targetinfo();
  inline ::std::string* release_targetinfo();
  inline void set_allocated_targetinfo(::std::string* targetinfo);

  // optional bytes gid = 3;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 3;
  inline const ::std::string& gid() const;
  inline void set_gid(const ::std::string& value);
  inline void set_gid(const char* value);
  inline void set_gid(const void* value, size_t size);
  inline ::std::string* mutable_gid();
  inline ::std::string* release_gid();
  inline void set_allocated_gid(::std::string* gid);

  // @@protoc_insertion_point(class_scope:aesm.message.Response.InitQuoteResponse)
 private:
  inline void set_has_errorcode();
  inline void clear_has_errorcode();
  inline void set_has_targetinfo();
  inline void clear_has_targetinfo();
  inline void set_has_gid();
  inline void clear_has_gid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* targetinfo_;
  ::std::string* gid_;
  ::google::protobuf::uint32 errorcode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Response_InitQuoteResponse* default_instance_;
};
// -------------------------------------------------------------------

class Response_GetQuoteResponse : public ::google::protobuf::Message {
 public:
  Response_GetQuoteResponse();
  virtual ~Response_GetQuoteResponse();

  Response_GetQuoteResponse(const Response_GetQuoteResponse& from);

  inline Response_GetQuoteResponse& operator=(const Response_GetQuoteResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response_GetQuoteResponse& default_instance();

  void Swap(Response_GetQuoteResponse* other);

  // implements Message ----------------------------------------------

  Response_GetQuoteResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Response_GetQuoteResponse& from);
  void MergeFrom(const Response_GetQuoteResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 errorCode = 1 [default = 1];
  inline bool has_errorcode() const;
  inline void clear_errorcode();
  static const int kErrorCodeFieldNumber = 1;
  inline ::google::protobuf::uint32 errorcode() const;
  inline void set_errorcode(::google::protobuf::uint32 value);

  // optional bytes quote = 2;
  inline bool has_quote() const;
  inline void clear_quote();
  static const int kQuoteFieldNumber = 2;
  inline const ::std::string& quote() const;
  inline void set_quote(const ::std::string& value);
  inline void set_quote(const char* value);
  inline void set_quote(const void* value, size_t size);
  inline ::std::string* mutable_quote();
  inline ::std::string* release_quote();
  inline void set_allocated_quote(::std::string* quote);

  // optional bytes qe_report = 3;
  inline bool has_qe_report() const;
  inline void clear_qe_report();
  static const int kQeReportFieldNumber = 3;
  inline const ::std::string& qe_report() const;
  inline void set_qe_report(const ::std::string& value);
  inline void set_qe_report(const char* value);
  inline void set_qe_report(const void* value, size_t size);
  inline ::std::string* mutable_qe_report();
  inline ::std::string* release_qe_report();
  inline void set_allocated_qe_report(::std::string* qe_report);

  // @@protoc_insertion_point(class_scope:aesm.message.Response.GetQuoteResponse)
 private:
  inline void set_has_errorcode();
  inline void clear_has_errorcode();
  inline void set_has_quote();
  inline void clear_has_quote();
  inline void set_has_qe_report();
  inline void clear_has_qe_report();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* quote_;
  ::std::string* qe_report_;
  ::google::protobuf::uint32 errorcode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Response_GetQuoteResponse* default_instance_;
};
// -------------------------------------------------------------------

class Response_GetLaunchTokenResponse : public ::google::protobuf::Message {
 public:
  Response_GetLaunchTokenResponse();
  virtual ~Response_GetLaunchTokenResponse();

  Response_GetLaunchTokenResponse(const Response_GetLaunchTokenResponse& from);

  inline Response_GetLaunchTokenResponse& operator=(const Response_GetLaunchTokenResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response_GetLaunchTokenResponse& default_instance();

  void Swap(Response_GetLaunchTokenResponse* other);

  // implements Message ----------------------------------------------

  Response_GetLaunchTokenResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Response_GetLaunchTokenResponse& from);
  void MergeFrom(const Response_GetLaunchTokenResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 errorCode = 1 [default = 1];
  inline bool has_errorcode() const;
  inline void clear_errorcode();
  static const int kErrorCodeFieldNumber = 1;
  inline ::google::protobuf::uint32 errorcode() const;
  inline void set_errorcode(::google::protobuf::uint32 value);

  // optional bytes token = 2;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 2;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const void* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // @@protoc_insertion_point(class_scope:aesm.message.Response.GetLaunchTokenResponse)
 private:
  inline void set_has_errorcode();
  inline void clear_has_errorcode();
  inline void set_has_token();
  inline void clear_has_token();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* token_;
  ::google::protobuf::uint32 errorcode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Response_GetLaunchTokenResponse* default_instance_;
};
// -------------------------------------------------------------------

class Response_ReportAttestationErrorResponse : public ::google::protobuf::Message {
 public:
  Response_ReportAttestationErrorResponse();
  virtual ~Response_ReportAttestationErrorResponse();

  Response_ReportAttestationErrorResponse(const Response_ReportAttestationErrorResponse& from);

  inline Response_ReportAttestationErrorResponse& operator=(const Response_ReportAttestationErrorResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response_ReportAttestationErrorResponse& default_instance();

  void Swap(Response_ReportAttestationErrorResponse* other);

  // implements Message ----------------------------------------------

  Response_ReportAttestationErrorResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Response_ReportAttestationErrorResponse& from);
  void MergeFrom(const Response_ReportAttestationErrorResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 errorCode = 1 [default = 1];
  inline bool has_errorcode() const;
  inline void clear_errorcode();
  static const int kErrorCodeFieldNumber = 1;
  inline ::google::protobuf::uint32 errorcode() const;
  inline void set_errorcode(::google::protobuf::uint32 value);

  // optional bytes platform_update_info = 2;
  inline bool has_platform_update_info() const;
  inline void clear_platform_update_info();
  static const int kPlatformUpdateInfoFieldNumber = 2;
  inline const ::std::string& platform_update_info() const;
  inline void set_platform_update_info(const ::std::string& value);
  inline void set_platform_update_info(const char* value);
  inline void set_platform_update_info(const void* value, size_t size);
  inline ::std::string* mutable_platform_update_info();
  inline ::std::string* release_platform_update_info();
  inline void set_allocated_platform_update_info(::std::string* platform_update_info);

  // @@protoc_insertion_point(class_scope:aesm.message.Response.ReportAttestationErrorResponse)
 private:
  inline void set_has_errorcode();
  inline void clear_has_errorcode();
  inline void set_has_platform_update_info();
  inline void clear_has_platform_update_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* platform_update_info_;
  ::google::protobuf::uint32 errorcode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Response_ReportAttestationErrorResponse* default_instance_;
};
// -------------------------------------------------------------------

class Response_CreateSessionResponse : public ::google::protobuf::Message {
 public:
  Response_CreateSessionResponse();
  virtual ~Response_CreateSessionResponse();

  Response_CreateSessionResponse(const Response_CreateSessionResponse& from);

  inline Response_CreateSessionResponse& operator=(const Response_CreateSessionResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response_CreateSessionResponse& default_instance();

  void Swap(Response_CreateSessionResponse* other);

  // implements Message ----------------------------------------------

  Response_CreateSessionResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Response_CreateSessionResponse& from);
  void MergeFrom(const Response_CreateSessionResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 errorCode = 1 [default = 1];
  inline bool has_errorcode() const;
  inline void clear_errorcode();
  static const int kErrorCodeFieldNumber = 1;
  inline ::google::protobuf::uint32 errorcode() const;
  inline void set_errorcode(::google::protobuf::uint32 value);

  // optional uint32 session_id = 2;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 2;
  inline ::google::protobuf::uint32 session_id() const;
  inline void set_session_id(::google::protobuf::uint32 value);

  // optional bytes se_dh_msg1 = 3;
  inline bool has_se_dh_msg1() const;
  inline void clear_se_dh_msg1();
  static const int kSeDhMsg1FieldNumber = 3;
  inline const ::std::string& se_dh_msg1() const;
  inline void set_se_dh_msg1(const ::std::string& value);
  inline void set_se_dh_msg1(const char* value);
  inline void set_se_dh_msg1(const void* value, size_t size);
  inline ::std::string* mutable_se_dh_msg1();
  inline ::std::string* release_se_dh_msg1();
  inline void set_allocated_se_dh_msg1(::std::string* se_dh_msg1);

  // @@protoc_insertion_point(class_scope:aesm.message.Response.CreateSessionResponse)
 private:
  inline void set_has_errorcode();
  inline void clear_has_errorcode();
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_se_dh_msg1();
  inline void clear_has_se_dh_msg1();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 errorcode_;
  ::google::protobuf::uint32 session_id_;
  ::std::string* se_dh_msg1_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Response_CreateSessionResponse* default_instance_;
};
// -------------------------------------------------------------------

class Response_InvokeServiceResponse : public ::google::protobuf::Message {
 public:
  Response_InvokeServiceResponse();
  virtual ~Response_InvokeServiceResponse();

  Response_InvokeServiceResponse(const Response_InvokeServiceResponse& from);

  inline Response_InvokeServiceResponse& operator=(const Response_InvokeServiceResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response_InvokeServiceResponse& default_instance();

  void Swap(Response_InvokeServiceResponse* other);

  // implements Message ----------------------------------------------

  Response_InvokeServiceResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Response_InvokeServiceResponse& from);
  void MergeFrom(const Response_InvokeServiceResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 errorCode = 1 [default = 1];
  inline bool has_errorcode() const;
  inline void clear_errorcode();
  static const int kErrorCodeFieldNumber = 1;
  inline ::google::protobuf::uint32 errorcode() const;
  inline void set_errorcode(::google::protobuf::uint32 value);

  // optional bytes pse_message = 2;
  inline bool has_pse_message() const;
  inline void clear_pse_message();
  static const int kPseMessageFieldNumber = 2;
  inline const ::std::string& pse_message() const;
  inline void set_pse_message(const ::std::string& value);
  inline void set_pse_message(const char* value);
  inline void set_pse_message(const void* value, size_t size);
  inline ::std::string* mutable_pse_message();
  inline ::std::string* release_pse_message();
  inline void set_allocated_pse_message(::std::string* pse_message);

  // @@protoc_insertion_point(class_scope:aesm.message.Response.InvokeServiceResponse)
 private:
  inline void set_has_errorcode();
  inline void clear_has_errorcode();
  inline void set_has_pse_message();
  inline void clear_has_pse_message();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* pse_message_;
  ::google::protobuf::uint32 errorcode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Response_InvokeServiceResponse* default_instance_;
};
// -------------------------------------------------------------------

class Response_ExchangeReportResponse : public ::google::protobuf::Message {
 public:
  Response_ExchangeReportResponse();
  virtual ~Response_ExchangeReportResponse();

  Response_ExchangeReportResponse(const Response_ExchangeReportResponse& from);

  inline Response_ExchangeReportResponse& operator=(const Response_ExchangeReportResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response_ExchangeReportResponse& default_instance();

  void Swap(Response_ExchangeReportResponse* other);

  // implements Message ----------------------------------------------

  Response_ExchangeReportResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Response_ExchangeReportResponse& from);
  void MergeFrom(const Response_ExchangeReportResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 errorCode = 1 [default = 1];
  inline bool has_errorcode() const;
  inline void clear_errorcode();
  static const int kErrorCodeFieldNumber = 1;
  inline ::google::protobuf::uint32 errorcode() const;
  inline void set_errorcode(::google::protobuf::uint32 value);

  // optional bytes se_dh_msg3 = 2;
  inline bool has_se_dh_msg3() const;
  inline void clear_se_dh_msg3();
  static const int kSeDhMsg3FieldNumber = 2;
  inline const ::std::string& se_dh_msg3() const;
  inline void set_se_dh_msg3(const ::std::string& value);
  inline void set_se_dh_msg3(const char* value);
  inline void set_se_dh_msg3(const void* value, size_t size);
  inline ::std::string* mutable_se_dh_msg3();
  inline ::std::string* release_se_dh_msg3();
  inline void set_allocated_se_dh_msg3(::std::string* se_dh_msg3);

  // @@protoc_insertion_point(class_scope:aesm.message.Response.ExchangeReportResponse)
 private:
  inline void set_has_errorcode();
  inline void clear_has_errorcode();
  inline void set_has_se_dh_msg3();
  inline void clear_has_se_dh_msg3();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* se_dh_msg3_;
  ::google::protobuf::uint32 errorcode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Response_ExchangeReportResponse* default_instance_;
};
// -------------------------------------------------------------------

class Response_CloseSessionResponse : public ::google::protobuf::Message {
 public:
  Response_CloseSessionResponse();
  virtual ~Response_CloseSessionResponse();

  Response_CloseSessionResponse(const Response_CloseSessionResponse& from);

  inline Response_CloseSessionResponse& operator=(const Response_CloseSessionResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response_CloseSessionResponse& default_instance();

  void Swap(Response_CloseSessionResponse* other);

  // implements Message ----------------------------------------------

  Response_CloseSessionResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Response_CloseSessionResponse& from);
  void MergeFrom(const Response_CloseSessionResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 errorCode = 1 [default = 1];
  inline bool has_errorcode() const;
  inline void clear_errorcode();
  static const int kErrorCodeFieldNumber = 1;
  inline ::google::protobuf::uint32 errorcode() const;
  inline void set_errorcode(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aesm.message.Response.CloseSessionResponse)
 private:
  inline void set_has_errorcode();
  inline void clear_has_errorcode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 errorcode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Response_CloseSessionResponse* default_instance_;
};
// -------------------------------------------------------------------

class Response_GetPsCapResponse : public ::google::protobuf::Message {
 public:
  Response_GetPsCapResponse();
  virtual ~Response_GetPsCapResponse();

  Response_GetPsCapResponse(const Response_GetPsCapResponse& from);

  inline Response_GetPsCapResponse& operator=(const Response_GetPsCapResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response_GetPsCapResponse& default_instance();

  void Swap(Response_GetPsCapResponse* other);

  // implements Message ----------------------------------------------

  Response_GetPsCapResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Response_GetPsCapResponse& from);
  void MergeFrom(const Response_GetPsCapResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 errorCode = 1 [default = 1];
  inline bool has_errorcode() const;
  inline void clear_errorcode();
  static const int kErrorCodeFieldNumber = 1;
  inline ::google::protobuf::uint32 errorcode() const;
  inline void set_errorcode(::google::protobuf::uint32 value);

  // optional uint64 ps_cap = 2;
  inline bool has_ps_cap() const;
  inline void clear_ps_cap();
  static const int kPsCapFieldNumber = 2;
  inline ::google::protobuf::uint64 ps_cap() const;
  inline void set_ps_cap(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:aesm.message.Response.GetPsCapResponse)
 private:
  inline void set_has_errorcode();
  inline void clear_has_errorcode();
  inline void set_has_ps_cap();
  inline void clear_has_ps_cap();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 ps_cap_;
  ::google::protobuf::uint32 errorcode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Response_GetPsCapResponse* default_instance_;
};
// -------------------------------------------------------------------

class Response_GetWhiteListSizeResponse : public ::google::protobuf::Message {
 public:
  Response_GetWhiteListSizeResponse();
  virtual ~Response_GetWhiteListSizeResponse();

  Response_GetWhiteListSizeResponse(const Response_GetWhiteListSizeResponse& from);

  inline Response_GetWhiteListSizeResponse& operator=(const Response_GetWhiteListSizeResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response_GetWhiteListSizeResponse& default_instance();

  void Swap(Response_GetWhiteListSizeResponse* other);

  // implements Message ----------------------------------------------

  Response_GetWhiteListSizeResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Response_GetWhiteListSizeResponse& from);
  void MergeFrom(const Response_GetWhiteListSizeResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 errorCode = 1 [default = 1];
  inline bool has_errorcode() const;
  inline void clear_errorcode();
  static const int kErrorCodeFieldNumber = 1;
  inline ::google::protobuf::uint32 errorcode() const;
  inline void set_errorcode(::google::protobuf::uint32 value);

  // optional uint32 white_list_size = 2;
  inline bool has_white_list_size() const;
  inline void clear_white_list_size();
  static const int kWhiteListSizeFieldNumber = 2;
  inline ::google::protobuf::uint32 white_list_size() const;
  inline void set_white_list_size(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aesm.message.Response.GetWhiteListSizeResponse)
 private:
  inline void set_has_errorcode();
  inline void clear_has_errorcode();
  inline void set_has_white_list_size();
  inline void clear_has_white_list_size();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 errorcode_;
  ::google::protobuf::uint32 white_list_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Response_GetWhiteListSizeResponse* default_instance_;
};
// -------------------------------------------------------------------

class Response_GetWhiteListResponse : public ::google::protobuf::Message {
 public:
  Response_GetWhiteListResponse();
  virtual ~Response_GetWhiteListResponse();

  Response_GetWhiteListResponse(const Response_GetWhiteListResponse& from);

  inline Response_GetWhiteListResponse& operator=(const Response_GetWhiteListResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response_GetWhiteListResponse& default_instance();

  void Swap(Response_GetWhiteListResponse* other);

  // implements Message ----------------------------------------------

  Response_GetWhiteListResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Response_GetWhiteListResponse& from);
  void MergeFrom(const Response_GetWhiteListResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 errorCode = 1 [default = 1];
  inline bool has_errorcode() const;
  inline void clear_errorcode();
  static const int kErrorCodeFieldNumber = 1;
  inline ::google::protobuf::uint32 errorcode() const;
  inline void set_errorcode(::google::protobuf::uint32 value);

  // optional bytes white_list = 2;
  inline bool has_white_list() const;
  inline void clear_white_list();
  static const int kWhiteListFieldNumber = 2;
  inline const ::std::string& white_list() const;
  inline void set_white_list(const ::std::string& value);
  inline void set_white_list(const char* value);
  inline void set_white_list(const void* value, size_t size);
  inline ::std::string* mutable_white_list();
  inline ::std::string* release_white_list();
  inline void set_allocated_white_list(::std::string* white_list);

  // @@protoc_insertion_point(class_scope:aesm.message.Response.GetWhiteListResponse)
 private:
  inline void set_has_errorcode();
  inline void clear_has_errorcode();
  inline void set_has_white_list();
  inline void clear_has_white_list();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* white_list_;
  ::google::protobuf::uint32 errorcode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Response_GetWhiteListResponse* default_instance_;
};
// -------------------------------------------------------------------

class Response_SGXGetExtendedEpidGroupIdResponse : public ::google::protobuf::Message {
 public:
  Response_SGXGetExtendedEpidGroupIdResponse();
  virtual ~Response_SGXGetExtendedEpidGroupIdResponse();

  Response_SGXGetExtendedEpidGroupIdResponse(const Response_SGXGetExtendedEpidGroupIdResponse& from);

  inline Response_SGXGetExtendedEpidGroupIdResponse& operator=(const Response_SGXGetExtendedEpidGroupIdResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response_SGXGetExtendedEpidGroupIdResponse& default_instance();

  void Swap(Response_SGXGetExtendedEpidGroupIdResponse* other);

  // implements Message ----------------------------------------------

  Response_SGXGetExtendedEpidGroupIdResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Response_SGXGetExtendedEpidGroupIdResponse& from);
  void MergeFrom(const Response_SGXGetExtendedEpidGroupIdResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 errorCode = 1 [default = 1];
  inline bool has_errorcode() const;
  inline void clear_errorcode();
  static const int kErrorCodeFieldNumber = 1;
  inline ::google::protobuf::uint32 errorcode() const;
  inline void set_errorcode(::google::protobuf::uint32 value);

  // optional uint32 x_group_id = 2;
  inline bool has_x_group_id() const;
  inline void clear_x_group_id();
  static const int kXGroupIdFieldNumber = 2;
  inline ::google::protobuf::uint32 x_group_id() const;
  inline void set_x_group_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aesm.message.Response.SGXGetExtendedEpidGroupIdResponse)
 private:
  inline void set_has_errorcode();
  inline void clear_has_errorcode();
  inline void set_has_x_group_id();
  inline void clear_has_x_group_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 errorcode_;
  ::google::protobuf::uint32 x_group_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Response_SGXGetExtendedEpidGroupIdResponse* default_instance_;
};
// -------------------------------------------------------------------

class Response_SGXSwitchExtendedEpidGroupResponse : public ::google::protobuf::Message {
 public:
  Response_SGXSwitchExtendedEpidGroupResponse();
  virtual ~Response_SGXSwitchExtendedEpidGroupResponse();

  Response_SGXSwitchExtendedEpidGroupResponse(const Response_SGXSwitchExtendedEpidGroupResponse& from);

  inline Response_SGXSwitchExtendedEpidGroupResponse& operator=(const Response_SGXSwitchExtendedEpidGroupResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response_SGXSwitchExtendedEpidGroupResponse& default_instance();

  void Swap(Response_SGXSwitchExtendedEpidGroupResponse* other);

  // implements Message ----------------------------------------------

  Response_SGXSwitchExtendedEpidGroupResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Response_SGXSwitchExtendedEpidGroupResponse& from);
  void MergeFrom(const Response_SGXSwitchExtendedEpidGroupResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 errorCode = 1 [default = 1];
  inline bool has_errorcode() const;
  inline void clear_errorcode();
  static const int kErrorCodeFieldNumber = 1;
  inline ::google::protobuf::uint32 errorcode() const;
  inline void set_errorcode(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aesm.message.Response.SGXSwitchExtendedEpidGroupResponse)
 private:
  inline void set_has_errorcode();
  inline void clear_has_errorcode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 errorcode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Response_SGXSwitchExtendedEpidGroupResponse* default_instance_;
};
// -------------------------------------------------------------------

class Response : public ::google::protobuf::Message {
 public:
  Response();
  virtual ~Response();

  Response(const Response& from);

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response& default_instance();

  void Swap(Response* other);

  // implements Message ----------------------------------------------

  Response* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Response& from);
  void MergeFrom(const Response& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Response_InitQuoteResponse InitQuoteResponse;
  typedef Response_GetQuoteResponse GetQuoteResponse;
  typedef Response_GetLaunchTokenResponse GetLaunchTokenResponse;
  typedef Response_ReportAttestationErrorResponse ReportAttestationErrorResponse;
  typedef Response_CreateSessionResponse CreateSessionResponse;
  typedef Response_InvokeServiceResponse InvokeServiceResponse;
  typedef Response_ExchangeReportResponse ExchangeReportResponse;
  typedef Response_CloseSessionResponse CloseSessionResponse;
  typedef Response_GetPsCapResponse GetPsCapResponse;
  typedef Response_GetWhiteListSizeResponse GetWhiteListSizeResponse;
  typedef Response_GetWhiteListResponse GetWhiteListResponse;
  typedef Response_SGXGetExtendedEpidGroupIdResponse SGXGetExtendedEpidGroupIdResponse;
  typedef Response_SGXSwitchExtendedEpidGroupResponse SGXSwitchExtendedEpidGroupResponse;

  // accessors -------------------------------------------------------

  // optional .aesm.message.Response.InitQuoteResponse initQuoteRes = 1;
  inline bool has_initquoteres() const;
  inline void clear_initquoteres();
  static const int kInitQuoteResFieldNumber = 1;
  inline const ::aesm::message::Response_InitQuoteResponse& initquoteres() const;
  inline ::aesm::message::Response_InitQuoteResponse* mutable_initquoteres();
  inline ::aesm::message::Response_InitQuoteResponse* release_initquoteres();
  inline void set_allocated_initquoteres(::aesm::message::Response_InitQuoteResponse* initquoteres);

  // optional .aesm.message.Response.GetQuoteResponse getQuoteRes = 2;
  inline bool has_getquoteres() const;
  inline void clear_getquoteres();
  static const int kGetQuoteResFieldNumber = 2;
  inline const ::aesm::message::Response_GetQuoteResponse& getquoteres() const;
  inline ::aesm::message::Response_GetQuoteResponse* mutable_getquoteres();
  inline ::aesm::message::Response_GetQuoteResponse* release_getquoteres();
  inline void set_allocated_getquoteres(::aesm::message::Response_GetQuoteResponse* getquoteres);

  // optional .aesm.message.Response.GetLaunchTokenResponse getLicTokenRes = 3;
  inline bool has_getlictokenres() const;
  inline void clear_getlictokenres();
  static const int kGetLicTokenResFieldNumber = 3;
  inline const ::aesm::message::Response_GetLaunchTokenResponse& getlictokenres() const;
  inline ::aesm::message::Response_GetLaunchTokenResponse* mutable_getlictokenres();
  inline ::aesm::message::Response_GetLaunchTokenResponse* release_getlictokenres();
  inline void set_allocated_getlictokenres(::aesm::message::Response_GetLaunchTokenResponse* getlictokenres);

  // optional .aesm.message.Response.ReportAttestationErrorResponse reportErrRes = 4;
  inline bool has_reporterrres() const;
  inline void clear_reporterrres();
  static const int kReportErrResFieldNumber = 4;
  inline const ::aesm::message::Response_ReportAttestationErrorResponse& reporterrres() const;
  inline ::aesm::message::Response_ReportAttestationErrorResponse* mutable_reporterrres();
  inline ::aesm::message::Response_ReportAttestationErrorResponse* release_reporterrres();
  inline void set_allocated_reporterrres(::aesm::message::Response_ReportAttestationErrorResponse* reporterrres);

  // optional .aesm.message.Response.CreateSessionResponse createSessionRes = 5;
  inline bool has_createsessionres() const;
  inline void clear_createsessionres();
  static const int kCreateSessionResFieldNumber = 5;
  inline const ::aesm::message::Response_CreateSessionResponse& createsessionres() const;
  inline ::aesm::message::Response_CreateSessionResponse* mutable_createsessionres();
  inline ::aesm::message::Response_CreateSessionResponse* release_createsessionres();
  inline void set_allocated_createsessionres(::aesm::message::Response_CreateSessionResponse* createsessionres);

  // optional .aesm.message.Response.InvokeServiceResponse invokeServiceRes = 6;
  inline bool has_invokeserviceres() const;
  inline void clear_invokeserviceres();
  static const int kInvokeServiceResFieldNumber = 6;
  inline const ::aesm::message::Response_InvokeServiceResponse& invokeserviceres() const;
  inline ::aesm::message::Response_InvokeServiceResponse* mutable_invokeserviceres();
  inline ::aesm::message::Response_InvokeServiceResponse* release_invokeserviceres();
  inline void set_allocated_invokeserviceres(::aesm::message::Response_InvokeServiceResponse* invokeserviceres);

  // optional .aesm.message.Response.ExchangeReportResponse exchangeReportRes = 7;
  inline bool has_exchangereportres() const;
  inline void clear_exchangereportres();
  static const int kExchangeReportResFieldNumber = 7;
  inline const ::aesm::message::Response_ExchangeReportResponse& exchangereportres() const;
  inline ::aesm::message::Response_ExchangeReportResponse* mutable_exchangereportres();
  inline ::aesm::message::Response_ExchangeReportResponse* release_exchangereportres();
  inline void set_allocated_exchangereportres(::aesm::message::Response_ExchangeReportResponse* exchangereportres);

  // optional .aesm.message.Response.CloseSessionResponse closeSessionRes = 8;
  inline bool has_closesessionres() const;
  inline void clear_closesessionres();
  static const int kCloseSessionResFieldNumber = 8;
  inline const ::aesm::message::Response_CloseSessionResponse& closesessionres() const;
  inline ::aesm::message::Response_CloseSessionResponse* mutable_closesessionres();
  inline ::aesm::message::Response_CloseSessionResponse* release_closesessionres();
  inline void set_allocated_closesessionres(::aesm::message::Response_CloseSessionResponse* closesessionres);

  // optional .aesm.message.Response.GetPsCapResponse getPsCapRes = 9;
  inline bool has_getpscapres() const;
  inline void clear_getpscapres();
  static const int kGetPsCapResFieldNumber = 9;
  inline const ::aesm::message::Response_GetPsCapResponse& getpscapres() const;
  inline ::aesm::message::Response_GetPsCapResponse* mutable_getpscapres();
  inline ::aesm::message::Response_GetPsCapResponse* release_getpscapres();
  inline void set_allocated_getpscapres(::aesm::message::Response_GetPsCapResponse* getpscapres);

  // optional .aesm.message.Response.GetWhiteListSizeResponse getWhiteListSizeRes = 10;
  inline bool has_getwhitelistsizeres() const;
  inline void clear_getwhitelistsizeres();
  static const int kGetWhiteListSizeResFieldNumber = 10;
  inline const ::aesm::message::Response_GetWhiteListSizeResponse& getwhitelistsizeres() const;
  inline ::aesm::message::Response_GetWhiteListSizeResponse* mutable_getwhitelistsizeres();
  inline ::aesm::message::Response_GetWhiteListSizeResponse* release_getwhitelistsizeres();
  inline void set_allocated_getwhitelistsizeres(::aesm::message::Response_GetWhiteListSizeResponse* getwhitelistsizeres);

  // optional .aesm.message.Response.GetWhiteListResponse getWhiteListRes = 11;
  inline bool has_getwhitelistres() const;
  inline void clear_getwhitelistres();
  static const int kGetWhiteListResFieldNumber = 11;
  inline const ::aesm::message::Response_GetWhiteListResponse& getwhitelistres() const;
  inline ::aesm::message::Response_GetWhiteListResponse* mutable_getwhitelistres();
  inline ::aesm::message::Response_GetWhiteListResponse* release_getwhitelistres();
  inline void set_allocated_getwhitelistres(::aesm::message::Response_GetWhiteListResponse* getwhitelistres);

  // optional .aesm.message.Response.SGXGetExtendedEpidGroupIdResponse sgxGetExtendedEpidGroupIdRes = 12;
  inline bool has_sgxgetextendedepidgroupidres() const;
  inline void clear_sgxgetextendedepidgroupidres();
  static const int kSgxGetExtendedEpidGroupIdResFieldNumber = 12;
  inline const ::aesm::message::Response_SGXGetExtendedEpidGroupIdResponse& sgxgetextendedepidgroupidres() const;
  inline ::aesm::message::Response_SGXGetExtendedEpidGroupIdResponse* mutable_sgxgetextendedepidgroupidres();
  inline ::aesm::message::Response_SGXGetExtendedEpidGroupIdResponse* release_sgxgetextendedepidgroupidres();
  inline void set_allocated_sgxgetextendedepidgroupidres(::aesm::message::Response_SGXGetExtendedEpidGroupIdResponse* sgxgetextendedepidgroupidres);

  // optional .aesm.message.Response.SGXSwitchExtendedEpidGroupResponse sgxSwitchExtendedEpidGroupRes = 13;
  inline bool has_sgxswitchextendedepidgroupres() const;
  inline void clear_sgxswitchextendedepidgroupres();
  static const int kSgxSwitchExtendedEpidGroupResFieldNumber = 13;
  inline const ::aesm::message::Response_SGXSwitchExtendedEpidGroupResponse& sgxswitchextendedepidgroupres() const;
  inline ::aesm::message::Response_SGXSwitchExtendedEpidGroupResponse* mutable_sgxswitchextendedepidgroupres();
  inline ::aesm::message::Response_SGXSwitchExtendedEpidGroupResponse* release_sgxswitchextendedepidgroupres();
  inline void set_allocated_sgxswitchextendedepidgroupres(::aesm::message::Response_SGXSwitchExtendedEpidGroupResponse* sgxswitchextendedepidgroupres);

  // @@protoc_insertion_point(class_scope:aesm.message.Response)
 private:
  inline void set_has_initquoteres();
  inline void clear_has_initquoteres();
  inline void set_has_getquoteres();
  inline void clear_has_getquoteres();
  inline void set_has_getlictokenres();
  inline void clear_has_getlictokenres();
  inline void set_has_reporterrres();
  inline void clear_has_reporterrres();
  inline void set_has_createsessionres();
  inline void clear_has_createsessionres();
  inline void set_has_invokeserviceres();
  inline void clear_has_invokeserviceres();
  inline void set_has_exchangereportres();
  inline void clear_has_exchangereportres();
  inline void set_has_closesessionres();
  inline void clear_has_closesessionres();
  inline void set_has_getpscapres();
  inline void clear_has_getpscapres();
  inline void set_has_getwhitelistsizeres();
  inline void clear_has_getwhitelistsizeres();
  inline void set_has_getwhitelistres();
  inline void clear_has_getwhitelistres();
  inline void set_has_sgxgetextendedepidgroupidres();
  inline void clear_has_sgxgetextendedepidgroupidres();
  inline void set_has_sgxswitchextendedepidgroupres();
  inline void clear_has_sgxswitchextendedepidgroupres();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::aesm::message::Response_InitQuoteResponse* initquoteres_;
  ::aesm::message::Response_GetQuoteResponse* getquoteres_;
  ::aesm::message::Response_GetLaunchTokenResponse* getlictokenres_;
  ::aesm::message::Response_ReportAttestationErrorResponse* reporterrres_;
  ::aesm::message::Response_CreateSessionResponse* createsessionres_;
  ::aesm::message::Response_InvokeServiceResponse* invokeserviceres_;
  ::aesm::message::Response_ExchangeReportResponse* exchangereportres_;
  ::aesm::message::Response_CloseSessionResponse* closesessionres_;
  ::aesm::message::Response_GetPsCapResponse* getpscapres_;
  ::aesm::message::Response_GetWhiteListSizeResponse* getwhitelistsizeres_;
  ::aesm::message::Response_GetWhiteListResponse* getwhitelistres_;
  ::aesm::message::Response_SGXGetExtendedEpidGroupIdResponse* sgxgetextendedepidgroupidres_;
  ::aesm::message::Response_SGXSwitchExtendedEpidGroupResponse* sgxswitchextendedepidgroupres_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Response* default_instance_;
};
// ===================================================================


// ===================================================================

// Request_InitQuoteRequest

// optional uint32 timeout = 9;
inline bool Request_InitQuoteRequest::has_timeout() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request_InitQuoteRequest::set_has_timeout() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request_InitQuoteRequest::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request_InitQuoteRequest::clear_timeout() {
  timeout_ = 0u;
  clear_has_timeout();
}
inline ::google::protobuf::uint32 Request_InitQuoteRequest::timeout() const {
  return timeout_;
}
inline void Request_InitQuoteRequest::set_timeout(::google::protobuf::uint32 value) {
  set_has_timeout();
  timeout_ = value;
}

// -------------------------------------------------------------------

// Request_GetQuoteRequest

// required bytes report = 1;
inline bool Request_GetQuoteRequest::has_report() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request_GetQuoteRequest::set_has_report() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request_GetQuoteRequest::clear_has_report() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request_GetQuoteRequest::clear_report() {
  if (report_ != &::google::protobuf::internal::kEmptyString) {
    report_->clear();
  }
  clear_has_report();
}
inline const ::std::string& Request_GetQuoteRequest::report() const {
  return *report_;
}
inline void Request_GetQuoteRequest::set_report(const ::std::string& value) {
  set_has_report();
  if (report_ == &::google::protobuf::internal::kEmptyString) {
    report_ = new ::std::string;
  }
  report_->assign(value);
}
inline void Request_GetQuoteRequest::set_report(const char* value) {
  set_has_report();
  if (report_ == &::google::protobuf::internal::kEmptyString) {
    report_ = new ::std::string;
  }
  report_->assign(value);
}
inline void Request_GetQuoteRequest::set_report(const void* value, size_t size) {
  set_has_report();
  if (report_ == &::google::protobuf::internal::kEmptyString) {
    report_ = new ::std::string;
  }
  report_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Request_GetQuoteRequest::mutable_report() {
  set_has_report();
  if (report_ == &::google::protobuf::internal::kEmptyString) {
    report_ = new ::std::string;
  }
  return report_;
}
inline ::std::string* Request_GetQuoteRequest::release_report() {
  clear_has_report();
  if (report_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = report_;
    report_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Request_GetQuoteRequest::set_allocated_report(::std::string* report) {
  if (report_ != &::google::protobuf::internal::kEmptyString) {
    delete report_;
  }
  if (report) {
    set_has_report();
    report_ = report;
  } else {
    clear_has_report();
    report_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 quote_type = 2;
inline bool Request_GetQuoteRequest::has_quote_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Request_GetQuoteRequest::set_has_quote_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Request_GetQuoteRequest::clear_has_quote_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Request_GetQuoteRequest::clear_quote_type() {
  quote_type_ = 0u;
  clear_has_quote_type();
}
inline ::google::protobuf::uint32 Request_GetQuoteRequest::quote_type() const {
  return quote_type_;
}
inline void Request_GetQuoteRequest::set_quote_type(::google::protobuf::uint32 value) {
  set_has_quote_type();
  quote_type_ = value;
}

// required bytes spid = 3;
inline bool Request_GetQuoteRequest::has_spid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Request_GetQuoteRequest::set_has_spid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Request_GetQuoteRequest::clear_has_spid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Request_GetQuoteRequest::clear_spid() {
  if (spid_ != &::google::protobuf::internal::kEmptyString) {
    spid_->clear();
  }
  clear_has_spid();
}
inline const ::std::string& Request_GetQuoteRequest::spid() const {
  return *spid_;
}
inline void Request_GetQuoteRequest::set_spid(const ::std::string& value) {
  set_has_spid();
  if (spid_ == &::google::protobuf::internal::kEmptyString) {
    spid_ = new ::std::string;
  }
  spid_->assign(value);
}
inline void Request_GetQuoteRequest::set_spid(const char* value) {
  set_has_spid();
  if (spid_ == &::google::protobuf::internal::kEmptyString) {
    spid_ = new ::std::string;
  }
  spid_->assign(value);
}
inline void Request_GetQuoteRequest::set_spid(const void* value, size_t size) {
  set_has_spid();
  if (spid_ == &::google::protobuf::internal::kEmptyString) {
    spid_ = new ::std::string;
  }
  spid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Request_GetQuoteRequest::mutable_spid() {
  set_has_spid();
  if (spid_ == &::google::protobuf::internal::kEmptyString) {
    spid_ = new ::std::string;
  }
  return spid_;
}
inline ::std::string* Request_GetQuoteRequest::release_spid() {
  clear_has_spid();
  if (spid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = spid_;
    spid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Request_GetQuoteRequest::set_allocated_spid(::std::string* spid) {
  if (spid_ != &::google::protobuf::internal::kEmptyString) {
    delete spid_;
  }
  if (spid) {
    set_has_spid();
    spid_ = spid;
  } else {
    clear_has_spid();
    spid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes nonce = 4;
inline bool Request_GetQuoteRequest::has_nonce() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Request_GetQuoteRequest::set_has_nonce() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Request_GetQuoteRequest::clear_has_nonce() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Request_GetQuoteRequest::clear_nonce() {
  if (nonce_ != &::google::protobuf::internal::kEmptyString) {
    nonce_->clear();
  }
  clear_has_nonce();
}
inline const ::std::string& Request_GetQuoteRequest::nonce() const {
  return *nonce_;
}
inline void Request_GetQuoteRequest::set_nonce(const ::std::string& value) {
  set_has_nonce();
  if (nonce_ == &::google::protobuf::internal::kEmptyString) {
    nonce_ = new ::std::string;
  }
  nonce_->assign(value);
}
inline void Request_GetQuoteRequest::set_nonce(const char* value) {
  set_has_nonce();
  if (nonce_ == &::google::protobuf::internal::kEmptyString) {
    nonce_ = new ::std::string;
  }
  nonce_->assign(value);
}
inline void Request_GetQuoteRequest::set_nonce(const void* value, size_t size) {
  set_has_nonce();
  if (nonce_ == &::google::protobuf::internal::kEmptyString) {
    nonce_ = new ::std::string;
  }
  nonce_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Request_GetQuoteRequest::mutable_nonce() {
  set_has_nonce();
  if (nonce_ == &::google::protobuf::internal::kEmptyString) {
    nonce_ = new ::std::string;
  }
  return nonce_;
}
inline ::std::string* Request_GetQuoteRequest::release_nonce() {
  clear_has_nonce();
  if (nonce_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nonce_;
    nonce_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Request_GetQuoteRequest::set_allocated_nonce(::std::string* nonce) {
  if (nonce_ != &::google::protobuf::internal::kEmptyString) {
    delete nonce_;
  }
  if (nonce) {
    set_has_nonce();
    nonce_ = nonce;
  } else {
    clear_has_nonce();
    nonce_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes sig_rl = 5;
inline bool Request_GetQuoteRequest::has_sig_rl() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Request_GetQuoteRequest::set_has_sig_rl() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Request_GetQuoteRequest::clear_has_sig_rl() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Request_GetQuoteRequest::clear_sig_rl() {
  if (sig_rl_ != &::google::protobuf::internal::kEmptyString) {
    sig_rl_->clear();
  }
  clear_has_sig_rl();
}
inline const ::std::string& Request_GetQuoteRequest::sig_rl() const {
  return *sig_rl_;
}
inline void Request_GetQuoteRequest::set_sig_rl(const ::std::string& value) {
  set_has_sig_rl();
  if (sig_rl_ == &::google::protobuf::internal::kEmptyString) {
    sig_rl_ = new ::std::string;
  }
  sig_rl_->assign(value);
}
inline void Request_GetQuoteRequest::set_sig_rl(const char* value) {
  set_has_sig_rl();
  if (sig_rl_ == &::google::protobuf::internal::kEmptyString) {
    sig_rl_ = new ::std::string;
  }
  sig_rl_->assign(value);
}
inline void Request_GetQuoteRequest::set_sig_rl(const void* value, size_t size) {
  set_has_sig_rl();
  if (sig_rl_ == &::google::protobuf::internal::kEmptyString) {
    sig_rl_ = new ::std::string;
  }
  sig_rl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Request_GetQuoteRequest::mutable_sig_rl() {
  set_has_sig_rl();
  if (sig_rl_ == &::google::protobuf::internal::kEmptyString) {
    sig_rl_ = new ::std::string;
  }
  return sig_rl_;
}
inline ::std::string* Request_GetQuoteRequest::release_sig_rl() {
  clear_has_sig_rl();
  if (sig_rl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sig_rl_;
    sig_rl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Request_GetQuoteRequest::set_allocated_sig_rl(::std::string* sig_rl) {
  if (sig_rl_ != &::google::protobuf::internal::kEmptyString) {
    delete sig_rl_;
  }
  if (sig_rl) {
    set_has_sig_rl();
    sig_rl_ = sig_rl;
  } else {
    clear_has_sig_rl();
    sig_rl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 buf_size = 6;
inline bool Request_GetQuoteRequest::has_buf_size() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Request_GetQuoteRequest::set_has_buf_size() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Request_GetQuoteRequest::clear_has_buf_size() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Request_GetQuoteRequest::clear_buf_size() {
  buf_size_ = 0u;
  clear_has_buf_size();
}
inline ::google::protobuf::uint32 Request_GetQuoteRequest::buf_size() const {
  return buf_size_;
}
inline void Request_GetQuoteRequest::set_buf_size(::google::protobuf::uint32 value) {
  set_has_buf_size();
  buf_size_ = value;
}

// optional bool qe_report = 7;
inline bool Request_GetQuoteRequest::has_qe_report() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Request_GetQuoteRequest::set_has_qe_report() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Request_GetQuoteRequest::clear_has_qe_report() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Request_GetQuoteRequest::clear_qe_report() {
  qe_report_ = false;
  clear_has_qe_report();
}
inline bool Request_GetQuoteRequest::qe_report() const {
  return qe_report_;
}
inline void Request_GetQuoteRequest::set_qe_report(bool value) {
  set_has_qe_report();
  qe_report_ = value;
}

// optional uint32 timeout = 9;
inline bool Request_GetQuoteRequest::has_timeout() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Request_GetQuoteRequest::set_has_timeout() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Request_GetQuoteRequest::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Request_GetQuoteRequest::clear_timeout() {
  timeout_ = 0u;
  clear_has_timeout();
}
inline ::google::protobuf::uint32 Request_GetQuoteRequest::timeout() const {
  return timeout_;
}
inline void Request_GetQuoteRequest::set_timeout(::google::protobuf::uint32 value) {
  set_has_timeout();
  timeout_ = value;
}

// -------------------------------------------------------------------

// Request_GetLaunchTokenRequest

// required bytes mr_enclave = 1;
inline bool Request_GetLaunchTokenRequest::has_mr_enclave() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request_GetLaunchTokenRequest::set_has_mr_enclave() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request_GetLaunchTokenRequest::clear_has_mr_enclave() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request_GetLaunchTokenRequest::clear_mr_enclave() {
  if (mr_enclave_ != &::google::protobuf::internal::kEmptyString) {
    mr_enclave_->clear();
  }
  clear_has_mr_enclave();
}
inline const ::std::string& Request_GetLaunchTokenRequest::mr_enclave() const {
  return *mr_enclave_;
}
inline void Request_GetLaunchTokenRequest::set_mr_enclave(const ::std::string& value) {
  set_has_mr_enclave();
  if (mr_enclave_ == &::google::protobuf::internal::kEmptyString) {
    mr_enclave_ = new ::std::string;
  }
  mr_enclave_->assign(value);
}
inline void Request_GetLaunchTokenRequest::set_mr_enclave(const char* value) {
  set_has_mr_enclave();
  if (mr_enclave_ == &::google::protobuf::internal::kEmptyString) {
    mr_enclave_ = new ::std::string;
  }
  mr_enclave_->assign(value);
}
inline void Request_GetLaunchTokenRequest::set_mr_enclave(const void* value, size_t size) {
  set_has_mr_enclave();
  if (mr_enclave_ == &::google::protobuf::internal::kEmptyString) {
    mr_enclave_ = new ::std::string;
  }
  mr_enclave_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Request_GetLaunchTokenRequest::mutable_mr_enclave() {
  set_has_mr_enclave();
  if (mr_enclave_ == &::google::protobuf::internal::kEmptyString) {
    mr_enclave_ = new ::std::string;
  }
  return mr_enclave_;
}
inline ::std::string* Request_GetLaunchTokenRequest::release_mr_enclave() {
  clear_has_mr_enclave();
  if (mr_enclave_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mr_enclave_;
    mr_enclave_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Request_GetLaunchTokenRequest::set_allocated_mr_enclave(::std::string* mr_enclave) {
  if (mr_enclave_ != &::google::protobuf::internal::kEmptyString) {
    delete mr_enclave_;
  }
  if (mr_enclave) {
    set_has_mr_enclave();
    mr_enclave_ = mr_enclave;
  } else {
    clear_has_mr_enclave();
    mr_enclave_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes mr_signer = 2;
inline bool Request_GetLaunchTokenRequest::has_mr_signer() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Request_GetLaunchTokenRequest::set_has_mr_signer() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Request_GetLaunchTokenRequest::clear_has_mr_signer() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Request_GetLaunchTokenRequest::clear_mr_signer() {
  if (mr_signer_ != &::google::protobuf::internal::kEmptyString) {
    mr_signer_->clear();
  }
  clear_has_mr_signer();
}
inline const ::std::string& Request_GetLaunchTokenRequest::mr_signer() const {
  return *mr_signer_;
}
inline void Request_GetLaunchTokenRequest::set_mr_signer(const ::std::string& value) {
  set_has_mr_signer();
  if (mr_signer_ == &::google::protobuf::internal::kEmptyString) {
    mr_signer_ = new ::std::string;
  }
  mr_signer_->assign(value);
}
inline void Request_GetLaunchTokenRequest::set_mr_signer(const char* value) {
  set_has_mr_signer();
  if (mr_signer_ == &::google::protobuf::internal::kEmptyString) {
    mr_signer_ = new ::std::string;
  }
  mr_signer_->assign(value);
}
inline void Request_GetLaunchTokenRequest::set_mr_signer(const void* value, size_t size) {
  set_has_mr_signer();
  if (mr_signer_ == &::google::protobuf::internal::kEmptyString) {
    mr_signer_ = new ::std::string;
  }
  mr_signer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Request_GetLaunchTokenRequest::mutable_mr_signer() {
  set_has_mr_signer();
  if (mr_signer_ == &::google::protobuf::internal::kEmptyString) {
    mr_signer_ = new ::std::string;
  }
  return mr_signer_;
}
inline ::std::string* Request_GetLaunchTokenRequest::release_mr_signer() {
  clear_has_mr_signer();
  if (mr_signer_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mr_signer_;
    mr_signer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Request_GetLaunchTokenRequest::set_allocated_mr_signer(::std::string* mr_signer) {
  if (mr_signer_ != &::google::protobuf::internal::kEmptyString) {
    delete mr_signer_;
  }
  if (mr_signer) {
    set_has_mr_signer();
    mr_signer_ = mr_signer;
  } else {
    clear_has_mr_signer();
    mr_signer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes se_attributes = 3;
inline bool Request_GetLaunchTokenRequest::has_se_attributes() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Request_GetLaunchTokenRequest::set_has_se_attributes() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Request_GetLaunchTokenRequest::clear_has_se_attributes() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Request_GetLaunchTokenRequest::clear_se_attributes() {
  if (se_attributes_ != &::google::protobuf::internal::kEmptyString) {
    se_attributes_->clear();
  }
  clear_has_se_attributes();
}
inline const ::std::string& Request_GetLaunchTokenRequest::se_attributes() const {
  return *se_attributes_;
}
inline void Request_GetLaunchTokenRequest::set_se_attributes(const ::std::string& value) {
  set_has_se_attributes();
  if (se_attributes_ == &::google::protobuf::internal::kEmptyString) {
    se_attributes_ = new ::std::string;
  }
  se_attributes_->assign(value);
}
inline void Request_GetLaunchTokenRequest::set_se_attributes(const char* value) {
  set_has_se_attributes();
  if (se_attributes_ == &::google::protobuf::internal::kEmptyString) {
    se_attributes_ = new ::std::string;
  }
  se_attributes_->assign(value);
}
inline void Request_GetLaunchTokenRequest::set_se_attributes(const void* value, size_t size) {
  set_has_se_attributes();
  if (se_attributes_ == &::google::protobuf::internal::kEmptyString) {
    se_attributes_ = new ::std::string;
  }
  se_attributes_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Request_GetLaunchTokenRequest::mutable_se_attributes() {
  set_has_se_attributes();
  if (se_attributes_ == &::google::protobuf::internal::kEmptyString) {
    se_attributes_ = new ::std::string;
  }
  return se_attributes_;
}
inline ::std::string* Request_GetLaunchTokenRequest::release_se_attributes() {
  clear_has_se_attributes();
  if (se_attributes_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = se_attributes_;
    se_attributes_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Request_GetLaunchTokenRequest::set_allocated_se_attributes(::std::string* se_attributes) {
  if (se_attributes_ != &::google::protobuf::internal::kEmptyString) {
    delete se_attributes_;
  }
  if (se_attributes) {
    set_has_se_attributes();
    se_attributes_ = se_attributes;
  } else {
    clear_has_se_attributes();
    se_attributes_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 timeout = 9;
inline bool Request_GetLaunchTokenRequest::has_timeout() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Request_GetLaunchTokenRequest::set_has_timeout() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Request_GetLaunchTokenRequest::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Request_GetLaunchTokenRequest::clear_timeout() {
  timeout_ = 0u;
  clear_has_timeout();
}
inline ::google::protobuf::uint32 Request_GetLaunchTokenRequest::timeout() const {
  return timeout_;
}
inline void Request_GetLaunchTokenRequest::set_timeout(::google::protobuf::uint32 value) {
  set_has_timeout();
  timeout_ = value;
}

// -------------------------------------------------------------------

// Request_ReportAttestationErrorRequest

// required bytes platform_info = 1;
inline bool Request_ReportAttestationErrorRequest::has_platform_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request_ReportAttestationErrorRequest::set_has_platform_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request_ReportAttestationErrorRequest::clear_has_platform_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request_ReportAttestationErrorRequest::clear_platform_info() {
  if (platform_info_ != &::google::protobuf::internal::kEmptyString) {
    platform_info_->clear();
  }
  clear_has_platform_info();
}
inline const ::std::string& Request_ReportAttestationErrorRequest::platform_info() const {
  return *platform_info_;
}
inline void Request_ReportAttestationErrorRequest::set_platform_info(const ::std::string& value) {
  set_has_platform_info();
  if (platform_info_ == &::google::protobuf::internal::kEmptyString) {
    platform_info_ = new ::std::string;
  }
  platform_info_->assign(value);
}
inline void Request_ReportAttestationErrorRequest::set_platform_info(const char* value) {
  set_has_platform_info();
  if (platform_info_ == &::google::protobuf::internal::kEmptyString) {
    platform_info_ = new ::std::string;
  }
  platform_info_->assign(value);
}
inline void Request_ReportAttestationErrorRequest::set_platform_info(const void* value, size_t size) {
  set_has_platform_info();
  if (platform_info_ == &::google::protobuf::internal::kEmptyString) {
    platform_info_ = new ::std::string;
  }
  platform_info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Request_ReportAttestationErrorRequest::mutable_platform_info() {
  set_has_platform_info();
  if (platform_info_ == &::google::protobuf::internal::kEmptyString) {
    platform_info_ = new ::std::string;
  }
  return platform_info_;
}
inline ::std::string* Request_ReportAttestationErrorRequest::release_platform_info() {
  clear_has_platform_info();
  if (platform_info_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = platform_info_;
    platform_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Request_ReportAttestationErrorRequest::set_allocated_platform_info(::std::string* platform_info) {
  if (platform_info_ != &::google::protobuf::internal::kEmptyString) {
    delete platform_info_;
  }
  if (platform_info) {
    set_has_platform_info();
    platform_info_ = platform_info;
  } else {
    clear_has_platform_info();
    platform_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 attestation_error_code = 2;
inline bool Request_ReportAttestationErrorRequest::has_attestation_error_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Request_ReportAttestationErrorRequest::set_has_attestation_error_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Request_ReportAttestationErrorRequest::clear_has_attestation_error_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Request_ReportAttestationErrorRequest::clear_attestation_error_code() {
  attestation_error_code_ = 0u;
  clear_has_attestation_error_code();
}
inline ::google::protobuf::uint32 Request_ReportAttestationErrorRequest::attestation_error_code() const {
  return attestation_error_code_;
}
inline void Request_ReportAttestationErrorRequest::set_attestation_error_code(::google::protobuf::uint32 value) {
  set_has_attestation_error_code();
  attestation_error_code_ = value;
}

// required uint32 update_info_size = 3;
inline bool Request_ReportAttestationErrorRequest::has_update_info_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Request_ReportAttestationErrorRequest::set_has_update_info_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Request_ReportAttestationErrorRequest::clear_has_update_info_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Request_ReportAttestationErrorRequest::clear_update_info_size() {
  update_info_size_ = 0u;
  clear_has_update_info_size();
}
inline ::google::protobuf::uint32 Request_ReportAttestationErrorRequest::update_info_size() const {
  return update_info_size_;
}
inline void Request_ReportAttestationErrorRequest::set_update_info_size(::google::protobuf::uint32 value) {
  set_has_update_info_size();
  update_info_size_ = value;
}

// optional uint32 timeout = 9;
inline bool Request_ReportAttestationErrorRequest::has_timeout() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Request_ReportAttestationErrorRequest::set_has_timeout() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Request_ReportAttestationErrorRequest::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Request_ReportAttestationErrorRequest::clear_timeout() {
  timeout_ = 0u;
  clear_has_timeout();
}
inline ::google::protobuf::uint32 Request_ReportAttestationErrorRequest::timeout() const {
  return timeout_;
}
inline void Request_ReportAttestationErrorRequest::set_timeout(::google::protobuf::uint32 value) {
  set_has_timeout();
  timeout_ = value;
}

// -------------------------------------------------------------------

// Request_CreateSessionRequest

// required uint32 dh_msg1_size = 1;
inline bool Request_CreateSessionRequest::has_dh_msg1_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request_CreateSessionRequest::set_has_dh_msg1_size() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request_CreateSessionRequest::clear_has_dh_msg1_size() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request_CreateSessionRequest::clear_dh_msg1_size() {
  dh_msg1_size_ = 0u;
  clear_has_dh_msg1_size();
}
inline ::google::protobuf::uint32 Request_CreateSessionRequest::dh_msg1_size() const {
  return dh_msg1_size_;
}
inline void Request_CreateSessionRequest::set_dh_msg1_size(::google::protobuf::uint32 value) {
  set_has_dh_msg1_size();
  dh_msg1_size_ = value;
}

// optional uint32 timeout = 9;
inline bool Request_CreateSessionRequest::has_timeout() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Request_CreateSessionRequest::set_has_timeout() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Request_CreateSessionRequest::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Request_CreateSessionRequest::clear_timeout() {
  timeout_ = 0u;
  clear_has_timeout();
}
inline ::google::protobuf::uint32 Request_CreateSessionRequest::timeout() const {
  return timeout_;
}
inline void Request_CreateSessionRequest::set_timeout(::google::protobuf::uint32 value) {
  set_has_timeout();
  timeout_ = value;
}

// -------------------------------------------------------------------

// Request_InvokeServiceRequest

// required bytes pse_message = 1;
inline bool Request_InvokeServiceRequest::has_pse_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request_InvokeServiceRequest::set_has_pse_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request_InvokeServiceRequest::clear_has_pse_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request_InvokeServiceRequest::clear_pse_message() {
  if (pse_message_ != &::google::protobuf::internal::kEmptyString) {
    pse_message_->clear();
  }
  clear_has_pse_message();
}
inline const ::std::string& Request_InvokeServiceRequest::pse_message() const {
  return *pse_message_;
}
inline void Request_InvokeServiceRequest::set_pse_message(const ::std::string& value) {
  set_has_pse_message();
  if (pse_message_ == &::google::protobuf::internal::kEmptyString) {
    pse_message_ = new ::std::string;
  }
  pse_message_->assign(value);
}
inline void Request_InvokeServiceRequest::set_pse_message(const char* value) {
  set_has_pse_message();
  if (pse_message_ == &::google::protobuf::internal::kEmptyString) {
    pse_message_ = new ::std::string;
  }
  pse_message_->assign(value);
}
inline void Request_InvokeServiceRequest::set_pse_message(const void* value, size_t size) {
  set_has_pse_message();
  if (pse_message_ == &::google::protobuf::internal::kEmptyString) {
    pse_message_ = new ::std::string;
  }
  pse_message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Request_InvokeServiceRequest::mutable_pse_message() {
  set_has_pse_message();
  if (pse_message_ == &::google::protobuf::internal::kEmptyString) {
    pse_message_ = new ::std::string;
  }
  return pse_message_;
}
inline ::std::string* Request_InvokeServiceRequest::release_pse_message() {
  clear_has_pse_message();
  if (pse_message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pse_message_;
    pse_message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Request_InvokeServiceRequest::set_allocated_pse_message(::std::string* pse_message) {
  if (pse_message_ != &::google::protobuf::internal::kEmptyString) {
    delete pse_message_;
  }
  if (pse_message) {
    set_has_pse_message();
    pse_message_ = pse_message;
  } else {
    clear_has_pse_message();
    pse_message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 pse_resp_size = 2;
inline bool Request_InvokeServiceRequest::has_pse_resp_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Request_InvokeServiceRequest::set_has_pse_resp_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Request_InvokeServiceRequest::clear_has_pse_resp_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Request_InvokeServiceRequest::clear_pse_resp_size() {
  pse_resp_size_ = 0u;
  clear_has_pse_resp_size();
}
inline ::google::protobuf::uint32 Request_InvokeServiceRequest::pse_resp_size() const {
  return pse_resp_size_;
}
inline void Request_InvokeServiceRequest::set_pse_resp_size(::google::protobuf::uint32 value) {
  set_has_pse_resp_size();
  pse_resp_size_ = value;
}

// optional uint32 timeout = 9;
inline bool Request_InvokeServiceRequest::has_timeout() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Request_InvokeServiceRequest::set_has_timeout() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Request_InvokeServiceRequest::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Request_InvokeServiceRequest::clear_timeout() {
  timeout_ = 0u;
  clear_has_timeout();
}
inline ::google::protobuf::uint32 Request_InvokeServiceRequest::timeout() const {
  return timeout_;
}
inline void Request_InvokeServiceRequest::set_timeout(::google::protobuf::uint32 value) {
  set_has_timeout();
  timeout_ = value;
}

// -------------------------------------------------------------------

// Request_ExchangeReportRequest

// required uint32 session_id = 1;
inline bool Request_ExchangeReportRequest::has_session_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request_ExchangeReportRequest::set_has_session_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request_ExchangeReportRequest::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request_ExchangeReportRequest::clear_session_id() {
  session_id_ = 0u;
  clear_has_session_id();
}
inline ::google::protobuf::uint32 Request_ExchangeReportRequest::session_id() const {
  return session_id_;
}
inline void Request_ExchangeReportRequest::set_session_id(::google::protobuf::uint32 value) {
  set_has_session_id();
  session_id_ = value;
}

// required bytes se_dh_msg2 = 2;
inline bool Request_ExchangeReportRequest::has_se_dh_msg2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Request_ExchangeReportRequest::set_has_se_dh_msg2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Request_ExchangeReportRequest::clear_has_se_dh_msg2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Request_ExchangeReportRequest::clear_se_dh_msg2() {
  if (se_dh_msg2_ != &::google::protobuf::internal::kEmptyString) {
    se_dh_msg2_->clear();
  }
  clear_has_se_dh_msg2();
}
inline const ::std::string& Request_ExchangeReportRequest::se_dh_msg2() const {
  return *se_dh_msg2_;
}
inline void Request_ExchangeReportRequest::set_se_dh_msg2(const ::std::string& value) {
  set_has_se_dh_msg2();
  if (se_dh_msg2_ == &::google::protobuf::internal::kEmptyString) {
    se_dh_msg2_ = new ::std::string;
  }
  se_dh_msg2_->assign(value);
}
inline void Request_ExchangeReportRequest::set_se_dh_msg2(const char* value) {
  set_has_se_dh_msg2();
  if (se_dh_msg2_ == &::google::protobuf::internal::kEmptyString) {
    se_dh_msg2_ = new ::std::string;
  }
  se_dh_msg2_->assign(value);
}
inline void Request_ExchangeReportRequest::set_se_dh_msg2(const void* value, size_t size) {
  set_has_se_dh_msg2();
  if (se_dh_msg2_ == &::google::protobuf::internal::kEmptyString) {
    se_dh_msg2_ = new ::std::string;
  }
  se_dh_msg2_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Request_ExchangeReportRequest::mutable_se_dh_msg2() {
  set_has_se_dh_msg2();
  if (se_dh_msg2_ == &::google::protobuf::internal::kEmptyString) {
    se_dh_msg2_ = new ::std::string;
  }
  return se_dh_msg2_;
}
inline ::std::string* Request_ExchangeReportRequest::release_se_dh_msg2() {
  clear_has_se_dh_msg2();
  if (se_dh_msg2_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = se_dh_msg2_;
    se_dh_msg2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Request_ExchangeReportRequest::set_allocated_se_dh_msg2(::std::string* se_dh_msg2) {
  if (se_dh_msg2_ != &::google::protobuf::internal::kEmptyString) {
    delete se_dh_msg2_;
  }
  if (se_dh_msg2) {
    set_has_se_dh_msg2();
    se_dh_msg2_ = se_dh_msg2;
  } else {
    clear_has_se_dh_msg2();
    se_dh_msg2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 se_dh_msg3_size = 3;
inline bool Request_ExchangeReportRequest::has_se_dh_msg3_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Request_ExchangeReportRequest::set_has_se_dh_msg3_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Request_ExchangeReportRequest::clear_has_se_dh_msg3_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Request_ExchangeReportRequest::clear_se_dh_msg3_size() {
  se_dh_msg3_size_ = 0u;
  clear_has_se_dh_msg3_size();
}
inline ::google::protobuf::uint32 Request_ExchangeReportRequest::se_dh_msg3_size() const {
  return se_dh_msg3_size_;
}
inline void Request_ExchangeReportRequest::set_se_dh_msg3_size(::google::protobuf::uint32 value) {
  set_has_se_dh_msg3_size();
  se_dh_msg3_size_ = value;
}

// optional uint32 timeout = 9;
inline bool Request_ExchangeReportRequest::has_timeout() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Request_ExchangeReportRequest::set_has_timeout() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Request_ExchangeReportRequest::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Request_ExchangeReportRequest::clear_timeout() {
  timeout_ = 0u;
  clear_has_timeout();
}
inline ::google::protobuf::uint32 Request_ExchangeReportRequest::timeout() const {
  return timeout_;
}
inline void Request_ExchangeReportRequest::set_timeout(::google::protobuf::uint32 value) {
  set_has_timeout();
  timeout_ = value;
}

// -------------------------------------------------------------------

// Request_CloseSessionRequest

// required uint32 session_id = 1;
inline bool Request_CloseSessionRequest::has_session_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request_CloseSessionRequest::set_has_session_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request_CloseSessionRequest::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request_CloseSessionRequest::clear_session_id() {
  session_id_ = 0u;
  clear_has_session_id();
}
inline ::google::protobuf::uint32 Request_CloseSessionRequest::session_id() const {
  return session_id_;
}
inline void Request_CloseSessionRequest::set_session_id(::google::protobuf::uint32 value) {
  set_has_session_id();
  session_id_ = value;
}

// optional uint32 timeout = 9;
inline bool Request_CloseSessionRequest::has_timeout() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Request_CloseSessionRequest::set_has_timeout() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Request_CloseSessionRequest::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Request_CloseSessionRequest::clear_timeout() {
  timeout_ = 0u;
  clear_has_timeout();
}
inline ::google::protobuf::uint32 Request_CloseSessionRequest::timeout() const {
  return timeout_;
}
inline void Request_CloseSessionRequest::set_timeout(::google::protobuf::uint32 value) {
  set_has_timeout();
  timeout_ = value;
}

// -------------------------------------------------------------------

// Request_GetPsCapRequest

// optional uint32 timeout = 9;
inline bool Request_GetPsCapRequest::has_timeout() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request_GetPsCapRequest::set_has_timeout() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request_GetPsCapRequest::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request_GetPsCapRequest::clear_timeout() {
  timeout_ = 0u;
  clear_has_timeout();
}
inline ::google::protobuf::uint32 Request_GetPsCapRequest::timeout() const {
  return timeout_;
}
inline void Request_GetPsCapRequest::set_timeout(::google::protobuf::uint32 value) {
  set_has_timeout();
  timeout_ = value;
}

// -------------------------------------------------------------------

// Request_GetWhiteListSizeRequest

// optional uint32 timeout = 9;
inline bool Request_GetWhiteListSizeRequest::has_timeout() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request_GetWhiteListSizeRequest::set_has_timeout() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request_GetWhiteListSizeRequest::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request_GetWhiteListSizeRequest::clear_timeout() {
  timeout_ = 0u;
  clear_has_timeout();
}
inline ::google::protobuf::uint32 Request_GetWhiteListSizeRequest::timeout() const {
  return timeout_;
}
inline void Request_GetWhiteListSizeRequest::set_timeout(::google::protobuf::uint32 value) {
  set_has_timeout();
  timeout_ = value;
}

// -------------------------------------------------------------------

// Request_GetWhiteListRequest

// optional uint32 white_list_size = 1;
inline bool Request_GetWhiteListRequest::has_white_list_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request_GetWhiteListRequest::set_has_white_list_size() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request_GetWhiteListRequest::clear_has_white_list_size() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request_GetWhiteListRequest::clear_white_list_size() {
  white_list_size_ = 0u;
  clear_has_white_list_size();
}
inline ::google::protobuf::uint32 Request_GetWhiteListRequest::white_list_size() const {
  return white_list_size_;
}
inline void Request_GetWhiteListRequest::set_white_list_size(::google::protobuf::uint32 value) {
  set_has_white_list_size();
  white_list_size_ = value;
}

// optional uint32 timeout = 9;
inline bool Request_GetWhiteListRequest::has_timeout() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Request_GetWhiteListRequest::set_has_timeout() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Request_GetWhiteListRequest::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Request_GetWhiteListRequest::clear_timeout() {
  timeout_ = 0u;
  clear_has_timeout();
}
inline ::google::protobuf::uint32 Request_GetWhiteListRequest::timeout() const {
  return timeout_;
}
inline void Request_GetWhiteListRequest::set_timeout(::google::protobuf::uint32 value) {
  set_has_timeout();
  timeout_ = value;
}

// -------------------------------------------------------------------

// Request_SGXGetExtendedEpidGroupIdRequest

// optional uint32 timeout = 9;
inline bool Request_SGXGetExtendedEpidGroupIdRequest::has_timeout() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request_SGXGetExtendedEpidGroupIdRequest::set_has_timeout() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request_SGXGetExtendedEpidGroupIdRequest::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request_SGXGetExtendedEpidGroupIdRequest::clear_timeout() {
  timeout_ = 0u;
  clear_has_timeout();
}
inline ::google::protobuf::uint32 Request_SGXGetExtendedEpidGroupIdRequest::timeout() const {
  return timeout_;
}
inline void Request_SGXGetExtendedEpidGroupIdRequest::set_timeout(::google::protobuf::uint32 value) {
  set_has_timeout();
  timeout_ = value;
}

// -------------------------------------------------------------------

// Request_SGXSwitchExtendedEpidGroupRequest

// optional uint32 x_group_id = 1;
inline bool Request_SGXSwitchExtendedEpidGroupRequest::has_x_group_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request_SGXSwitchExtendedEpidGroupRequest::set_has_x_group_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request_SGXSwitchExtendedEpidGroupRequest::clear_has_x_group_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request_SGXSwitchExtendedEpidGroupRequest::clear_x_group_id() {
  x_group_id_ = 0u;
  clear_has_x_group_id();
}
inline ::google::protobuf::uint32 Request_SGXSwitchExtendedEpidGroupRequest::x_group_id() const {
  return x_group_id_;
}
inline void Request_SGXSwitchExtendedEpidGroupRequest::set_x_group_id(::google::protobuf::uint32 value) {
  set_has_x_group_id();
  x_group_id_ = value;
}

// optional uint32 timeout = 9;
inline bool Request_SGXSwitchExtendedEpidGroupRequest::has_timeout() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Request_SGXSwitchExtendedEpidGroupRequest::set_has_timeout() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Request_SGXSwitchExtendedEpidGroupRequest::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Request_SGXSwitchExtendedEpidGroupRequest::clear_timeout() {
  timeout_ = 0u;
  clear_has_timeout();
}
inline ::google::protobuf::uint32 Request_SGXSwitchExtendedEpidGroupRequest::timeout() const {
  return timeout_;
}
inline void Request_SGXSwitchExtendedEpidGroupRequest::set_timeout(::google::protobuf::uint32 value) {
  set_has_timeout();
  timeout_ = value;
}

// -------------------------------------------------------------------

// Request

// optional .aesm.message.Request.InitQuoteRequest initQuoteReq = 1;
inline bool Request::has_initquotereq() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request::set_has_initquotereq() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request::clear_has_initquotereq() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request::clear_initquotereq() {
  if (initquotereq_ != NULL) initquotereq_->::aesm::message::Request_InitQuoteRequest::Clear();
  clear_has_initquotereq();
}
inline const ::aesm::message::Request_InitQuoteRequest& Request::initquotereq() const {
  return initquotereq_ != NULL ? *initquotereq_ : *default_instance_->initquotereq_;
}
inline ::aesm::message::Request_InitQuoteRequest* Request::mutable_initquotereq() {
  set_has_initquotereq();
  if (initquotereq_ == NULL) initquotereq_ = new ::aesm::message::Request_InitQuoteRequest;
  return initquotereq_;
}
inline ::aesm::message::Request_InitQuoteRequest* Request::release_initquotereq() {
  clear_has_initquotereq();
  ::aesm::message::Request_InitQuoteRequest* temp = initquotereq_;
  initquotereq_ = NULL;
  return temp;
}
inline void Request::set_allocated_initquotereq(::aesm::message::Request_InitQuoteRequest* initquotereq) {
  delete initquotereq_;
  initquotereq_ = initquotereq;
  if (initquotereq) {
    set_has_initquotereq();
  } else {
    clear_has_initquotereq();
  }
}

// optional .aesm.message.Request.GetQuoteRequest getQuoteReq = 2;
inline bool Request::has_getquotereq() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Request::set_has_getquotereq() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Request::clear_has_getquotereq() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Request::clear_getquotereq() {
  if (getquotereq_ != NULL) getquotereq_->::aesm::message::Request_GetQuoteRequest::Clear();
  clear_has_getquotereq();
}
inline const ::aesm::message::Request_GetQuoteRequest& Request::getquotereq() const {
  return getquotereq_ != NULL ? *getquotereq_ : *default_instance_->getquotereq_;
}
inline ::aesm::message::Request_GetQuoteRequest* Request::mutable_getquotereq() {
  set_has_getquotereq();
  if (getquotereq_ == NULL) getquotereq_ = new ::aesm::message::Request_GetQuoteRequest;
  return getquotereq_;
}
inline ::aesm::message::Request_GetQuoteRequest* Request::release_getquotereq() {
  clear_has_getquotereq();
  ::aesm::message::Request_GetQuoteRequest* temp = getquotereq_;
  getquotereq_ = NULL;
  return temp;
}
inline void Request::set_allocated_getquotereq(::aesm::message::Request_GetQuoteRequest* getquotereq) {
  delete getquotereq_;
  getquotereq_ = getquotereq;
  if (getquotereq) {
    set_has_getquotereq();
  } else {
    clear_has_getquotereq();
  }
}

// optional .aesm.message.Request.GetLaunchTokenRequest getLicTokenReq = 3;
inline bool Request::has_getlictokenreq() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Request::set_has_getlictokenreq() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Request::clear_has_getlictokenreq() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Request::clear_getlictokenreq() {
  if (getlictokenreq_ != NULL) getlictokenreq_->::aesm::message::Request_GetLaunchTokenRequest::Clear();
  clear_has_getlictokenreq();
}
inline const ::aesm::message::Request_GetLaunchTokenRequest& Request::getlictokenreq() const {
  return getlictokenreq_ != NULL ? *getlictokenreq_ : *default_instance_->getlictokenreq_;
}
inline ::aesm::message::Request_GetLaunchTokenRequest* Request::mutable_getlictokenreq() {
  set_has_getlictokenreq();
  if (getlictokenreq_ == NULL) getlictokenreq_ = new ::aesm::message::Request_GetLaunchTokenRequest;
  return getlictokenreq_;
}
inline ::aesm::message::Request_GetLaunchTokenRequest* Request::release_getlictokenreq() {
  clear_has_getlictokenreq();
  ::aesm::message::Request_GetLaunchTokenRequest* temp = getlictokenreq_;
  getlictokenreq_ = NULL;
  return temp;
}
inline void Request::set_allocated_getlictokenreq(::aesm::message::Request_GetLaunchTokenRequest* getlictokenreq) {
  delete getlictokenreq_;
  getlictokenreq_ = getlictokenreq;
  if (getlictokenreq) {
    set_has_getlictokenreq();
  } else {
    clear_has_getlictokenreq();
  }
}

// optional .aesm.message.Request.ReportAttestationErrorRequest reportErrReq = 4;
inline bool Request::has_reporterrreq() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Request::set_has_reporterrreq() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Request::clear_has_reporterrreq() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Request::clear_reporterrreq() {
  if (reporterrreq_ != NULL) reporterrreq_->::aesm::message::Request_ReportAttestationErrorRequest::Clear();
  clear_has_reporterrreq();
}
inline const ::aesm::message::Request_ReportAttestationErrorRequest& Request::reporterrreq() const {
  return reporterrreq_ != NULL ? *reporterrreq_ : *default_instance_->reporterrreq_;
}
inline ::aesm::message::Request_ReportAttestationErrorRequest* Request::mutable_reporterrreq() {
  set_has_reporterrreq();
  if (reporterrreq_ == NULL) reporterrreq_ = new ::aesm::message::Request_ReportAttestationErrorRequest;
  return reporterrreq_;
}
inline ::aesm::message::Request_ReportAttestationErrorRequest* Request::release_reporterrreq() {
  clear_has_reporterrreq();
  ::aesm::message::Request_ReportAttestationErrorRequest* temp = reporterrreq_;
  reporterrreq_ = NULL;
  return temp;
}
inline void Request::set_allocated_reporterrreq(::aesm::message::Request_ReportAttestationErrorRequest* reporterrreq) {
  delete reporterrreq_;
  reporterrreq_ = reporterrreq;
  if (reporterrreq) {
    set_has_reporterrreq();
  } else {
    clear_has_reporterrreq();
  }
}

// optional .aesm.message.Request.CreateSessionRequest createSessionReq = 5;
inline bool Request::has_createsessionreq() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Request::set_has_createsessionreq() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Request::clear_has_createsessionreq() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Request::clear_createsessionreq() {
  if (createsessionreq_ != NULL) createsessionreq_->::aesm::message::Request_CreateSessionRequest::Clear();
  clear_has_createsessionreq();
}
inline const ::aesm::message::Request_CreateSessionRequest& Request::createsessionreq() const {
  return createsessionreq_ != NULL ? *createsessionreq_ : *default_instance_->createsessionreq_;
}
inline ::aesm::message::Request_CreateSessionRequest* Request::mutable_createsessionreq() {
  set_has_createsessionreq();
  if (createsessionreq_ == NULL) createsessionreq_ = new ::aesm::message::Request_CreateSessionRequest;
  return createsessionreq_;
}
inline ::aesm::message::Request_CreateSessionRequest* Request::release_createsessionreq() {
  clear_has_createsessionreq();
  ::aesm::message::Request_CreateSessionRequest* temp = createsessionreq_;
  createsessionreq_ = NULL;
  return temp;
}
inline void Request::set_allocated_createsessionreq(::aesm::message::Request_CreateSessionRequest* createsessionreq) {
  delete createsessionreq_;
  createsessionreq_ = createsessionreq;
  if (createsessionreq) {
    set_has_createsessionreq();
  } else {
    clear_has_createsessionreq();
  }
}

// optional .aesm.message.Request.InvokeServiceRequest invokeServiceReq = 6;
inline bool Request::has_invokeservicereq() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Request::set_has_invokeservicereq() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Request::clear_has_invokeservicereq() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Request::clear_invokeservicereq() {
  if (invokeservicereq_ != NULL) invokeservicereq_->::aesm::message::Request_InvokeServiceRequest::Clear();
  clear_has_invokeservicereq();
}
inline const ::aesm::message::Request_InvokeServiceRequest& Request::invokeservicereq() const {
  return invokeservicereq_ != NULL ? *invokeservicereq_ : *default_instance_->invokeservicereq_;
}
inline ::aesm::message::Request_InvokeServiceRequest* Request::mutable_invokeservicereq() {
  set_has_invokeservicereq();
  if (invokeservicereq_ == NULL) invokeservicereq_ = new ::aesm::message::Request_InvokeServiceRequest;
  return invokeservicereq_;
}
inline ::aesm::message::Request_InvokeServiceRequest* Request::release_invokeservicereq() {
  clear_has_invokeservicereq();
  ::aesm::message::Request_InvokeServiceRequest* temp = invokeservicereq_;
  invokeservicereq_ = NULL;
  return temp;
}
inline void Request::set_allocated_invokeservicereq(::aesm::message::Request_InvokeServiceRequest* invokeservicereq) {
  delete invokeservicereq_;
  invokeservicereq_ = invokeservicereq;
  if (invokeservicereq) {
    set_has_invokeservicereq();
  } else {
    clear_has_invokeservicereq();
  }
}

// optional .aesm.message.Request.ExchangeReportRequest exchangeReportReq = 7;
inline bool Request::has_exchangereportreq() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Request::set_has_exchangereportreq() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Request::clear_has_exchangereportreq() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Request::clear_exchangereportreq() {
  if (exchangereportreq_ != NULL) exchangereportreq_->::aesm::message::Request_ExchangeReportRequest::Clear();
  clear_has_exchangereportreq();
}
inline const ::aesm::message::Request_ExchangeReportRequest& Request::exchangereportreq() const {
  return exchangereportreq_ != NULL ? *exchangereportreq_ : *default_instance_->exchangereportreq_;
}
inline ::aesm::message::Request_ExchangeReportRequest* Request::mutable_exchangereportreq() {
  set_has_exchangereportreq();
  if (exchangereportreq_ == NULL) exchangereportreq_ = new ::aesm::message::Request_ExchangeReportRequest;
  return exchangereportreq_;
}
inline ::aesm::message::Request_ExchangeReportRequest* Request::release_exchangereportreq() {
  clear_has_exchangereportreq();
  ::aesm::message::Request_ExchangeReportRequest* temp = exchangereportreq_;
  exchangereportreq_ = NULL;
  return temp;
}
inline void Request::set_allocated_exchangereportreq(::aesm::message::Request_ExchangeReportRequest* exchangereportreq) {
  delete exchangereportreq_;
  exchangereportreq_ = exchangereportreq;
  if (exchangereportreq) {
    set_has_exchangereportreq();
  } else {
    clear_has_exchangereportreq();
  }
}

// optional .aesm.message.Request.CloseSessionRequest closeSessionReq = 8;
inline bool Request::has_closesessionreq() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Request::set_has_closesessionreq() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Request::clear_has_closesessionreq() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Request::clear_closesessionreq() {
  if (closesessionreq_ != NULL) closesessionreq_->::aesm::message::Request_CloseSessionRequest::Clear();
  clear_has_closesessionreq();
}
inline const ::aesm::message::Request_CloseSessionRequest& Request::closesessionreq() const {
  return closesessionreq_ != NULL ? *closesessionreq_ : *default_instance_->closesessionreq_;
}
inline ::aesm::message::Request_CloseSessionRequest* Request::mutable_closesessionreq() {
  set_has_closesessionreq();
  if (closesessionreq_ == NULL) closesessionreq_ = new ::aesm::message::Request_CloseSessionRequest;
  return closesessionreq_;
}
inline ::aesm::message::Request_CloseSessionRequest* Request::release_closesessionreq() {
  clear_has_closesessionreq();
  ::aesm::message::Request_CloseSessionRequest* temp = closesessionreq_;
  closesessionreq_ = NULL;
  return temp;
}
inline void Request::set_allocated_closesessionreq(::aesm::message::Request_CloseSessionRequest* closesessionreq) {
  delete closesessionreq_;
  closesessionreq_ = closesessionreq;
  if (closesessionreq) {
    set_has_closesessionreq();
  } else {
    clear_has_closesessionreq();
  }
}

// optional .aesm.message.Request.GetPsCapRequest getPsCapReq = 9;
inline bool Request::has_getpscapreq() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Request::set_has_getpscapreq() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Request::clear_has_getpscapreq() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Request::clear_getpscapreq() {
  if (getpscapreq_ != NULL) getpscapreq_->::aesm::message::Request_GetPsCapRequest::Clear();
  clear_has_getpscapreq();
}
inline const ::aesm::message::Request_GetPsCapRequest& Request::getpscapreq() const {
  return getpscapreq_ != NULL ? *getpscapreq_ : *default_instance_->getpscapreq_;
}
inline ::aesm::message::Request_GetPsCapRequest* Request::mutable_getpscapreq() {
  set_has_getpscapreq();
  if (getpscapreq_ == NULL) getpscapreq_ = new ::aesm::message::Request_GetPsCapRequest;
  return getpscapreq_;
}
inline ::aesm::message::Request_GetPsCapRequest* Request::release_getpscapreq() {
  clear_has_getpscapreq();
  ::aesm::message::Request_GetPsCapRequest* temp = getpscapreq_;
  getpscapreq_ = NULL;
  return temp;
}
inline void Request::set_allocated_getpscapreq(::aesm::message::Request_GetPsCapRequest* getpscapreq) {
  delete getpscapreq_;
  getpscapreq_ = getpscapreq;
  if (getpscapreq) {
    set_has_getpscapreq();
  } else {
    clear_has_getpscapreq();
  }
}

// optional .aesm.message.Request.GetWhiteListSizeRequest getWhiteListSizeReq = 10;
inline bool Request::has_getwhitelistsizereq() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Request::set_has_getwhitelistsizereq() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Request::clear_has_getwhitelistsizereq() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Request::clear_getwhitelistsizereq() {
  if (getwhitelistsizereq_ != NULL) getwhitelistsizereq_->::aesm::message::Request_GetWhiteListSizeRequest::Clear();
  clear_has_getwhitelistsizereq();
}
inline const ::aesm::message::Request_GetWhiteListSizeRequest& Request::getwhitelistsizereq() const {
  return getwhitelistsizereq_ != NULL ? *getwhitelistsizereq_ : *default_instance_->getwhitelistsizereq_;
}
inline ::aesm::message::Request_GetWhiteListSizeRequest* Request::mutable_getwhitelistsizereq() {
  set_has_getwhitelistsizereq();
  if (getwhitelistsizereq_ == NULL) getwhitelistsizereq_ = new ::aesm::message::Request_GetWhiteListSizeRequest;
  return getwhitelistsizereq_;
}
inline ::aesm::message::Request_GetWhiteListSizeRequest* Request::release_getwhitelistsizereq() {
  clear_has_getwhitelistsizereq();
  ::aesm::message::Request_GetWhiteListSizeRequest* temp = getwhitelistsizereq_;
  getwhitelistsizereq_ = NULL;
  return temp;
}
inline void Request::set_allocated_getwhitelistsizereq(::aesm::message::Request_GetWhiteListSizeRequest* getwhitelistsizereq) {
  delete getwhitelistsizereq_;
  getwhitelistsizereq_ = getwhitelistsizereq;
  if (getwhitelistsizereq) {
    set_has_getwhitelistsizereq();
  } else {
    clear_has_getwhitelistsizereq();
  }
}

// optional .aesm.message.Request.GetWhiteListRequest getWhiteListReq = 11;
inline bool Request::has_getwhitelistreq() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Request::set_has_getwhitelistreq() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Request::clear_has_getwhitelistreq() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Request::clear_getwhitelistreq() {
  if (getwhitelistreq_ != NULL) getwhitelistreq_->::aesm::message::Request_GetWhiteListRequest::Clear();
  clear_has_getwhitelistreq();
}
inline const ::aesm::message::Request_GetWhiteListRequest& Request::getwhitelistreq() const {
  return getwhitelistreq_ != NULL ? *getwhitelistreq_ : *default_instance_->getwhitelistreq_;
}
inline ::aesm::message::Request_GetWhiteListRequest* Request::mutable_getwhitelistreq() {
  set_has_getwhitelistreq();
  if (getwhitelistreq_ == NULL) getwhitelistreq_ = new ::aesm::message::Request_GetWhiteListRequest;
  return getwhitelistreq_;
}
inline ::aesm::message::Request_GetWhiteListRequest* Request::release_getwhitelistreq() {
  clear_has_getwhitelistreq();
  ::aesm::message::Request_GetWhiteListRequest* temp = getwhitelistreq_;
  getwhitelistreq_ = NULL;
  return temp;
}
inline void Request::set_allocated_getwhitelistreq(::aesm::message::Request_GetWhiteListRequest* getwhitelistreq) {
  delete getwhitelistreq_;
  getwhitelistreq_ = getwhitelistreq;
  if (getwhitelistreq) {
    set_has_getwhitelistreq();
  } else {
    clear_has_getwhitelistreq();
  }
}

// optional .aesm.message.Request.SGXGetExtendedEpidGroupIdRequest sgxGetExtendedEpidGroupIdReq = 12;
inline bool Request::has_sgxgetextendedepidgroupidreq() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Request::set_has_sgxgetextendedepidgroupidreq() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Request::clear_has_sgxgetextendedepidgroupidreq() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Request::clear_sgxgetextendedepidgroupidreq() {
  if (sgxgetextendedepidgroupidreq_ != NULL) sgxgetextendedepidgroupidreq_->::aesm::message::Request_SGXGetExtendedEpidGroupIdRequest::Clear();
  clear_has_sgxgetextendedepidgroupidreq();
}
inline const ::aesm::message::Request_SGXGetExtendedEpidGroupIdRequest& Request::sgxgetextendedepidgroupidreq() const {
  return sgxgetextendedepidgroupidreq_ != NULL ? *sgxgetextendedepidgroupidreq_ : *default_instance_->sgxgetextendedepidgroupidreq_;
}
inline ::aesm::message::Request_SGXGetExtendedEpidGroupIdRequest* Request::mutable_sgxgetextendedepidgroupidreq() {
  set_has_sgxgetextendedepidgroupidreq();
  if (sgxgetextendedepidgroupidreq_ == NULL) sgxgetextendedepidgroupidreq_ = new ::aesm::message::Request_SGXGetExtendedEpidGroupIdRequest;
  return sgxgetextendedepidgroupidreq_;
}
inline ::aesm::message::Request_SGXGetExtendedEpidGroupIdRequest* Request::release_sgxgetextendedepidgroupidreq() {
  clear_has_sgxgetextendedepidgroupidreq();
  ::aesm::message::Request_SGXGetExtendedEpidGroupIdRequest* temp = sgxgetextendedepidgroupidreq_;
  sgxgetextendedepidgroupidreq_ = NULL;
  return temp;
}
inline void Request::set_allocated_sgxgetextendedepidgroupidreq(::aesm::message::Request_SGXGetExtendedEpidGroupIdRequest* sgxgetextendedepidgroupidreq) {
  delete sgxgetextendedepidgroupidreq_;
  sgxgetextendedepidgroupidreq_ = sgxgetextendedepidgroupidreq;
  if (sgxgetextendedepidgroupidreq) {
    set_has_sgxgetextendedepidgroupidreq();
  } else {
    clear_has_sgxgetextendedepidgroupidreq();
  }
}

// optional .aesm.message.Request.SGXSwitchExtendedEpidGroupRequest sgxSwitchExtendedEpidGroupReq = 13;
inline bool Request::has_sgxswitchextendedepidgroupreq() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Request::set_has_sgxswitchextendedepidgroupreq() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Request::clear_has_sgxswitchextendedepidgroupreq() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Request::clear_sgxswitchextendedepidgroupreq() {
  if (sgxswitchextendedepidgroupreq_ != NULL) sgxswitchextendedepidgroupreq_->::aesm::message::Request_SGXSwitchExtendedEpidGroupRequest::Clear();
  clear_has_sgxswitchextendedepidgroupreq();
}
inline const ::aesm::message::Request_SGXSwitchExtendedEpidGroupRequest& Request::sgxswitchextendedepidgroupreq() const {
  return sgxswitchextendedepidgroupreq_ != NULL ? *sgxswitchextendedepidgroupreq_ : *default_instance_->sgxswitchextendedepidgroupreq_;
}
inline ::aesm::message::Request_SGXSwitchExtendedEpidGroupRequest* Request::mutable_sgxswitchextendedepidgroupreq() {
  set_has_sgxswitchextendedepidgroupreq();
  if (sgxswitchextendedepidgroupreq_ == NULL) sgxswitchextendedepidgroupreq_ = new ::aesm::message::Request_SGXSwitchExtendedEpidGroupRequest;
  return sgxswitchextendedepidgroupreq_;
}
inline ::aesm::message::Request_SGXSwitchExtendedEpidGroupRequest* Request::release_sgxswitchextendedepidgroupreq() {
  clear_has_sgxswitchextendedepidgroupreq();
  ::aesm::message::Request_SGXSwitchExtendedEpidGroupRequest* temp = sgxswitchextendedepidgroupreq_;
  sgxswitchextendedepidgroupreq_ = NULL;
  return temp;
}
inline void Request::set_allocated_sgxswitchextendedepidgroupreq(::aesm::message::Request_SGXSwitchExtendedEpidGroupRequest* sgxswitchextendedepidgroupreq) {
  delete sgxswitchextendedepidgroupreq_;
  sgxswitchextendedepidgroupreq_ = sgxswitchextendedepidgroupreq;
  if (sgxswitchextendedepidgroupreq) {
    set_has_sgxswitchextendedepidgroupreq();
  } else {
    clear_has_sgxswitchextendedepidgroupreq();
  }
}

// -------------------------------------------------------------------

// Response_InitQuoteResponse

// required uint32 errorCode = 1 [default = 1];
inline bool Response_InitQuoteResponse::has_errorcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response_InitQuoteResponse::set_has_errorcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response_InitQuoteResponse::clear_has_errorcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response_InitQuoteResponse::clear_errorcode() {
  errorcode_ = 1u;
  clear_has_errorcode();
}
inline ::google::protobuf::uint32 Response_InitQuoteResponse::errorcode() const {
  return errorcode_;
}
inline void Response_InitQuoteResponse::set_errorcode(::google::protobuf::uint32 value) {
  set_has_errorcode();
  errorcode_ = value;
}

// optional bytes targetInfo = 2;
inline bool Response_InitQuoteResponse::has_targetinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response_InitQuoteResponse::set_has_targetinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response_InitQuoteResponse::clear_has_targetinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Response_InitQuoteResponse::clear_targetinfo() {
  if (targetinfo_ != &::google::protobuf::internal::kEmptyString) {
    targetinfo_->clear();
  }
  clear_has_targetinfo();
}
inline const ::std::string& Response_InitQuoteResponse::targetinfo() const {
  return *targetinfo_;
}
inline void Response_InitQuoteResponse::set_targetinfo(const ::std::string& value) {
  set_has_targetinfo();
  if (targetinfo_ == &::google::protobuf::internal::kEmptyString) {
    targetinfo_ = new ::std::string;
  }
  targetinfo_->assign(value);
}
inline void Response_InitQuoteResponse::set_targetinfo(const char* value) {
  set_has_targetinfo();
  if (targetinfo_ == &::google::protobuf::internal::kEmptyString) {
    targetinfo_ = new ::std::string;
  }
  targetinfo_->assign(value);
}
inline void Response_InitQuoteResponse::set_targetinfo(const void* value, size_t size) {
  set_has_targetinfo();
  if (targetinfo_ == &::google::protobuf::internal::kEmptyString) {
    targetinfo_ = new ::std::string;
  }
  targetinfo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Response_InitQuoteResponse::mutable_targetinfo() {
  set_has_targetinfo();
  if (targetinfo_ == &::google::protobuf::internal::kEmptyString) {
    targetinfo_ = new ::std::string;
  }
  return targetinfo_;
}
inline ::std::string* Response_InitQuoteResponse::release_targetinfo() {
  clear_has_targetinfo();
  if (targetinfo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = targetinfo_;
    targetinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Response_InitQuoteResponse::set_allocated_targetinfo(::std::string* targetinfo) {
  if (targetinfo_ != &::google::protobuf::internal::kEmptyString) {
    delete targetinfo_;
  }
  if (targetinfo) {
    set_has_targetinfo();
    targetinfo_ = targetinfo;
  } else {
    clear_has_targetinfo();
    targetinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes gid = 3;
inline bool Response_InitQuoteResponse::has_gid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Response_InitQuoteResponse::set_has_gid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Response_InitQuoteResponse::clear_has_gid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Response_InitQuoteResponse::clear_gid() {
  if (gid_ != &::google::protobuf::internal::kEmptyString) {
    gid_->clear();
  }
  clear_has_gid();
}
inline const ::std::string& Response_InitQuoteResponse::gid() const {
  return *gid_;
}
inline void Response_InitQuoteResponse::set_gid(const ::std::string& value) {
  set_has_gid();
  if (gid_ == &::google::protobuf::internal::kEmptyString) {
    gid_ = new ::std::string;
  }
  gid_->assign(value);
}
inline void Response_InitQuoteResponse::set_gid(const char* value) {
  set_has_gid();
  if (gid_ == &::google::protobuf::internal::kEmptyString) {
    gid_ = new ::std::string;
  }
  gid_->assign(value);
}
inline void Response_InitQuoteResponse::set_gid(const void* value, size_t size) {
  set_has_gid();
  if (gid_ == &::google::protobuf::internal::kEmptyString) {
    gid_ = new ::std::string;
  }
  gid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Response_InitQuoteResponse::mutable_gid() {
  set_has_gid();
  if (gid_ == &::google::protobuf::internal::kEmptyString) {
    gid_ = new ::std::string;
  }
  return gid_;
}
inline ::std::string* Response_InitQuoteResponse::release_gid() {
  clear_has_gid();
  if (gid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gid_;
    gid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Response_InitQuoteResponse::set_allocated_gid(::std::string* gid) {
  if (gid_ != &::google::protobuf::internal::kEmptyString) {
    delete gid_;
  }
  if (gid) {
    set_has_gid();
    gid_ = gid;
  } else {
    clear_has_gid();
    gid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Response_GetQuoteResponse

// required uint32 errorCode = 1 [default = 1];
inline bool Response_GetQuoteResponse::has_errorcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response_GetQuoteResponse::set_has_errorcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response_GetQuoteResponse::clear_has_errorcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response_GetQuoteResponse::clear_errorcode() {
  errorcode_ = 1u;
  clear_has_errorcode();
}
inline ::google::protobuf::uint32 Response_GetQuoteResponse::errorcode() const {
  return errorcode_;
}
inline void Response_GetQuoteResponse::set_errorcode(::google::protobuf::uint32 value) {
  set_has_errorcode();
  errorcode_ = value;
}

// optional bytes quote = 2;
inline bool Response_GetQuoteResponse::has_quote() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response_GetQuoteResponse::set_has_quote() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response_GetQuoteResponse::clear_has_quote() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Response_GetQuoteResponse::clear_quote() {
  if (quote_ != &::google::protobuf::internal::kEmptyString) {
    quote_->clear();
  }
  clear_has_quote();
}
inline const ::std::string& Response_GetQuoteResponse::quote() const {
  return *quote_;
}
inline void Response_GetQuoteResponse::set_quote(const ::std::string& value) {
  set_has_quote();
  if (quote_ == &::google::protobuf::internal::kEmptyString) {
    quote_ = new ::std::string;
  }
  quote_->assign(value);
}
inline void Response_GetQuoteResponse::set_quote(const char* value) {
  set_has_quote();
  if (quote_ == &::google::protobuf::internal::kEmptyString) {
    quote_ = new ::std::string;
  }
  quote_->assign(value);
}
inline void Response_GetQuoteResponse::set_quote(const void* value, size_t size) {
  set_has_quote();
  if (quote_ == &::google::protobuf::internal::kEmptyString) {
    quote_ = new ::std::string;
  }
  quote_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Response_GetQuoteResponse::mutable_quote() {
  set_has_quote();
  if (quote_ == &::google::protobuf::internal::kEmptyString) {
    quote_ = new ::std::string;
  }
  return quote_;
}
inline ::std::string* Response_GetQuoteResponse::release_quote() {
  clear_has_quote();
  if (quote_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = quote_;
    quote_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Response_GetQuoteResponse::set_allocated_quote(::std::string* quote) {
  if (quote_ != &::google::protobuf::internal::kEmptyString) {
    delete quote_;
  }
  if (quote) {
    set_has_quote();
    quote_ = quote;
  } else {
    clear_has_quote();
    quote_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes qe_report = 3;
inline bool Response_GetQuoteResponse::has_qe_report() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Response_GetQuoteResponse::set_has_qe_report() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Response_GetQuoteResponse::clear_has_qe_report() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Response_GetQuoteResponse::clear_qe_report() {
  if (qe_report_ != &::google::protobuf::internal::kEmptyString) {
    qe_report_->clear();
  }
  clear_has_qe_report();
}
inline const ::std::string& Response_GetQuoteResponse::qe_report() const {
  return *qe_report_;
}
inline void Response_GetQuoteResponse::set_qe_report(const ::std::string& value) {
  set_has_qe_report();
  if (qe_report_ == &::google::protobuf::internal::kEmptyString) {
    qe_report_ = new ::std::string;
  }
  qe_report_->assign(value);
}
inline void Response_GetQuoteResponse::set_qe_report(const char* value) {
  set_has_qe_report();
  if (qe_report_ == &::google::protobuf::internal::kEmptyString) {
    qe_report_ = new ::std::string;
  }
  qe_report_->assign(value);
}
inline void Response_GetQuoteResponse::set_qe_report(const void* value, size_t size) {
  set_has_qe_report();
  if (qe_report_ == &::google::protobuf::internal::kEmptyString) {
    qe_report_ = new ::std::string;
  }
  qe_report_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Response_GetQuoteResponse::mutable_qe_report() {
  set_has_qe_report();
  if (qe_report_ == &::google::protobuf::internal::kEmptyString) {
    qe_report_ = new ::std::string;
  }
  return qe_report_;
}
inline ::std::string* Response_GetQuoteResponse::release_qe_report() {
  clear_has_qe_report();
  if (qe_report_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = qe_report_;
    qe_report_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Response_GetQuoteResponse::set_allocated_qe_report(::std::string* qe_report) {
  if (qe_report_ != &::google::protobuf::internal::kEmptyString) {
    delete qe_report_;
  }
  if (qe_report) {
    set_has_qe_report();
    qe_report_ = qe_report;
  } else {
    clear_has_qe_report();
    qe_report_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Response_GetLaunchTokenResponse

// required uint32 errorCode = 1 [default = 1];
inline bool Response_GetLaunchTokenResponse::has_errorcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response_GetLaunchTokenResponse::set_has_errorcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response_GetLaunchTokenResponse::clear_has_errorcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response_GetLaunchTokenResponse::clear_errorcode() {
  errorcode_ = 1u;
  clear_has_errorcode();
}
inline ::google::protobuf::uint32 Response_GetLaunchTokenResponse::errorcode() const {
  return errorcode_;
}
inline void Response_GetLaunchTokenResponse::set_errorcode(::google::protobuf::uint32 value) {
  set_has_errorcode();
  errorcode_ = value;
}

// optional bytes token = 2;
inline bool Response_GetLaunchTokenResponse::has_token() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response_GetLaunchTokenResponse::set_has_token() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response_GetLaunchTokenResponse::clear_has_token() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Response_GetLaunchTokenResponse::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& Response_GetLaunchTokenResponse::token() const {
  return *token_;
}
inline void Response_GetLaunchTokenResponse::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void Response_GetLaunchTokenResponse::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void Response_GetLaunchTokenResponse::set_token(const void* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Response_GetLaunchTokenResponse::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* Response_GetLaunchTokenResponse::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Response_GetLaunchTokenResponse::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Response_ReportAttestationErrorResponse

// required uint32 errorCode = 1 [default = 1];
inline bool Response_ReportAttestationErrorResponse::has_errorcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response_ReportAttestationErrorResponse::set_has_errorcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response_ReportAttestationErrorResponse::clear_has_errorcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response_ReportAttestationErrorResponse::clear_errorcode() {
  errorcode_ = 1u;
  clear_has_errorcode();
}
inline ::google::protobuf::uint32 Response_ReportAttestationErrorResponse::errorcode() const {
  return errorcode_;
}
inline void Response_ReportAttestationErrorResponse::set_errorcode(::google::protobuf::uint32 value) {
  set_has_errorcode();
  errorcode_ = value;
}

// optional bytes platform_update_info = 2;
inline bool Response_ReportAttestationErrorResponse::has_platform_update_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response_ReportAttestationErrorResponse::set_has_platform_update_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response_ReportAttestationErrorResponse::clear_has_platform_update_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Response_ReportAttestationErrorResponse::clear_platform_update_info() {
  if (platform_update_info_ != &::google::protobuf::internal::kEmptyString) {
    platform_update_info_->clear();
  }
  clear_has_platform_update_info();
}
inline const ::std::string& Response_ReportAttestationErrorResponse::platform_update_info() const {
  return *platform_update_info_;
}
inline void Response_ReportAttestationErrorResponse::set_platform_update_info(const ::std::string& value) {
  set_has_platform_update_info();
  if (platform_update_info_ == &::google::protobuf::internal::kEmptyString) {
    platform_update_info_ = new ::std::string;
  }
  platform_update_info_->assign(value);
}
inline void Response_ReportAttestationErrorResponse::set_platform_update_info(const char* value) {
  set_has_platform_update_info();
  if (platform_update_info_ == &::google::protobuf::internal::kEmptyString) {
    platform_update_info_ = new ::std::string;
  }
  platform_update_info_->assign(value);
}
inline void Response_ReportAttestationErrorResponse::set_platform_update_info(const void* value, size_t size) {
  set_has_platform_update_info();
  if (platform_update_info_ == &::google::protobuf::internal::kEmptyString) {
    platform_update_info_ = new ::std::string;
  }
  platform_update_info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Response_ReportAttestationErrorResponse::mutable_platform_update_info() {
  set_has_platform_update_info();
  if (platform_update_info_ == &::google::protobuf::internal::kEmptyString) {
    platform_update_info_ = new ::std::string;
  }
  return platform_update_info_;
}
inline ::std::string* Response_ReportAttestationErrorResponse::release_platform_update_info() {
  clear_has_platform_update_info();
  if (platform_update_info_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = platform_update_info_;
    platform_update_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Response_ReportAttestationErrorResponse::set_allocated_platform_update_info(::std::string* platform_update_info) {
  if (platform_update_info_ != &::google::protobuf::internal::kEmptyString) {
    delete platform_update_info_;
  }
  if (platform_update_info) {
    set_has_platform_update_info();
    platform_update_info_ = platform_update_info;
  } else {
    clear_has_platform_update_info();
    platform_update_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Response_CreateSessionResponse

// required uint32 errorCode = 1 [default = 1];
inline bool Response_CreateSessionResponse::has_errorcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response_CreateSessionResponse::set_has_errorcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response_CreateSessionResponse::clear_has_errorcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response_CreateSessionResponse::clear_errorcode() {
  errorcode_ = 1u;
  clear_has_errorcode();
}
inline ::google::protobuf::uint32 Response_CreateSessionResponse::errorcode() const {
  return errorcode_;
}
inline void Response_CreateSessionResponse::set_errorcode(::google::protobuf::uint32 value) {
  set_has_errorcode();
  errorcode_ = value;
}

// optional uint32 session_id = 2;
inline bool Response_CreateSessionResponse::has_session_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response_CreateSessionResponse::set_has_session_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response_CreateSessionResponse::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Response_CreateSessionResponse::clear_session_id() {
  session_id_ = 0u;
  clear_has_session_id();
}
inline ::google::protobuf::uint32 Response_CreateSessionResponse::session_id() const {
  return session_id_;
}
inline void Response_CreateSessionResponse::set_session_id(::google::protobuf::uint32 value) {
  set_has_session_id();
  session_id_ = value;
}

// optional bytes se_dh_msg1 = 3;
inline bool Response_CreateSessionResponse::has_se_dh_msg1() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Response_CreateSessionResponse::set_has_se_dh_msg1() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Response_CreateSessionResponse::clear_has_se_dh_msg1() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Response_CreateSessionResponse::clear_se_dh_msg1() {
  if (se_dh_msg1_ != &::google::protobuf::internal::kEmptyString) {
    se_dh_msg1_->clear();
  }
  clear_has_se_dh_msg1();
}
inline const ::std::string& Response_CreateSessionResponse::se_dh_msg1() const {
  return *se_dh_msg1_;
}
inline void Response_CreateSessionResponse::set_se_dh_msg1(const ::std::string& value) {
  set_has_se_dh_msg1();
  if (se_dh_msg1_ == &::google::protobuf::internal::kEmptyString) {
    se_dh_msg1_ = new ::std::string;
  }
  se_dh_msg1_->assign(value);
}
inline void Response_CreateSessionResponse::set_se_dh_msg1(const char* value) {
  set_has_se_dh_msg1();
  if (se_dh_msg1_ == &::google::protobuf::internal::kEmptyString) {
    se_dh_msg1_ = new ::std::string;
  }
  se_dh_msg1_->assign(value);
}
inline void Response_CreateSessionResponse::set_se_dh_msg1(const void* value, size_t size) {
  set_has_se_dh_msg1();
  if (se_dh_msg1_ == &::google::protobuf::internal::kEmptyString) {
    se_dh_msg1_ = new ::std::string;
  }
  se_dh_msg1_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Response_CreateSessionResponse::mutable_se_dh_msg1() {
  set_has_se_dh_msg1();
  if (se_dh_msg1_ == &::google::protobuf::internal::kEmptyString) {
    se_dh_msg1_ = new ::std::string;
  }
  return se_dh_msg1_;
}
inline ::std::string* Response_CreateSessionResponse::release_se_dh_msg1() {
  clear_has_se_dh_msg1();
  if (se_dh_msg1_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = se_dh_msg1_;
    se_dh_msg1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Response_CreateSessionResponse::set_allocated_se_dh_msg1(::std::string* se_dh_msg1) {
  if (se_dh_msg1_ != &::google::protobuf::internal::kEmptyString) {
    delete se_dh_msg1_;
  }
  if (se_dh_msg1) {
    set_has_se_dh_msg1();
    se_dh_msg1_ = se_dh_msg1;
  } else {
    clear_has_se_dh_msg1();
    se_dh_msg1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Response_InvokeServiceResponse

// required uint32 errorCode = 1 [default = 1];
inline bool Response_InvokeServiceResponse::has_errorcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response_InvokeServiceResponse::set_has_errorcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response_InvokeServiceResponse::clear_has_errorcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response_InvokeServiceResponse::clear_errorcode() {
  errorcode_ = 1u;
  clear_has_errorcode();
}
inline ::google::protobuf::uint32 Response_InvokeServiceResponse::errorcode() const {
  return errorcode_;
}
inline void Response_InvokeServiceResponse::set_errorcode(::google::protobuf::uint32 value) {
  set_has_errorcode();
  errorcode_ = value;
}

// optional bytes pse_message = 2;
inline bool Response_InvokeServiceResponse::has_pse_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response_InvokeServiceResponse::set_has_pse_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response_InvokeServiceResponse::clear_has_pse_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Response_InvokeServiceResponse::clear_pse_message() {
  if (pse_message_ != &::google::protobuf::internal::kEmptyString) {
    pse_message_->clear();
  }
  clear_has_pse_message();
}
inline const ::std::string& Response_InvokeServiceResponse::pse_message() const {
  return *pse_message_;
}
inline void Response_InvokeServiceResponse::set_pse_message(const ::std::string& value) {
  set_has_pse_message();
  if (pse_message_ == &::google::protobuf::internal::kEmptyString) {
    pse_message_ = new ::std::string;
  }
  pse_message_->assign(value);
}
inline void Response_InvokeServiceResponse::set_pse_message(const char* value) {
  set_has_pse_message();
  if (pse_message_ == &::google::protobuf::internal::kEmptyString) {
    pse_message_ = new ::std::string;
  }
  pse_message_->assign(value);
}
inline void Response_InvokeServiceResponse::set_pse_message(const void* value, size_t size) {
  set_has_pse_message();
  if (pse_message_ == &::google::protobuf::internal::kEmptyString) {
    pse_message_ = new ::std::string;
  }
  pse_message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Response_InvokeServiceResponse::mutable_pse_message() {
  set_has_pse_message();
  if (pse_message_ == &::google::protobuf::internal::kEmptyString) {
    pse_message_ = new ::std::string;
  }
  return pse_message_;
}
inline ::std::string* Response_InvokeServiceResponse::release_pse_message() {
  clear_has_pse_message();
  if (pse_message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pse_message_;
    pse_message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Response_InvokeServiceResponse::set_allocated_pse_message(::std::string* pse_message) {
  if (pse_message_ != &::google::protobuf::internal::kEmptyString) {
    delete pse_message_;
  }
  if (pse_message) {
    set_has_pse_message();
    pse_message_ = pse_message;
  } else {
    clear_has_pse_message();
    pse_message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Response_ExchangeReportResponse

// required uint32 errorCode = 1 [default = 1];
inline bool Response_ExchangeReportResponse::has_errorcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response_ExchangeReportResponse::set_has_errorcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response_ExchangeReportResponse::clear_has_errorcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response_ExchangeReportResponse::clear_errorcode() {
  errorcode_ = 1u;
  clear_has_errorcode();
}
inline ::google::protobuf::uint32 Response_ExchangeReportResponse::errorcode() const {
  return errorcode_;
}
inline void Response_ExchangeReportResponse::set_errorcode(::google::protobuf::uint32 value) {
  set_has_errorcode();
  errorcode_ = value;
}

// optional bytes se_dh_msg3 = 2;
inline bool Response_ExchangeReportResponse::has_se_dh_msg3() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response_ExchangeReportResponse::set_has_se_dh_msg3() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response_ExchangeReportResponse::clear_has_se_dh_msg3() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Response_ExchangeReportResponse::clear_se_dh_msg3() {
  if (se_dh_msg3_ != &::google::protobuf::internal::kEmptyString) {
    se_dh_msg3_->clear();
  }
  clear_has_se_dh_msg3();
}
inline const ::std::string& Response_ExchangeReportResponse::se_dh_msg3() const {
  return *se_dh_msg3_;
}
inline void Response_ExchangeReportResponse::set_se_dh_msg3(const ::std::string& value) {
  set_has_se_dh_msg3();
  if (se_dh_msg3_ == &::google::protobuf::internal::kEmptyString) {
    se_dh_msg3_ = new ::std::string;
  }
  se_dh_msg3_->assign(value);
}
inline void Response_ExchangeReportResponse::set_se_dh_msg3(const char* value) {
  set_has_se_dh_msg3();
  if (se_dh_msg3_ == &::google::protobuf::internal::kEmptyString) {
    se_dh_msg3_ = new ::std::string;
  }
  se_dh_msg3_->assign(value);
}
inline void Response_ExchangeReportResponse::set_se_dh_msg3(const void* value, size_t size) {
  set_has_se_dh_msg3();
  if (se_dh_msg3_ == &::google::protobuf::internal::kEmptyString) {
    se_dh_msg3_ = new ::std::string;
  }
  se_dh_msg3_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Response_ExchangeReportResponse::mutable_se_dh_msg3() {
  set_has_se_dh_msg3();
  if (se_dh_msg3_ == &::google::protobuf::internal::kEmptyString) {
    se_dh_msg3_ = new ::std::string;
  }
  return se_dh_msg3_;
}
inline ::std::string* Response_ExchangeReportResponse::release_se_dh_msg3() {
  clear_has_se_dh_msg3();
  if (se_dh_msg3_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = se_dh_msg3_;
    se_dh_msg3_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Response_ExchangeReportResponse::set_allocated_se_dh_msg3(::std::string* se_dh_msg3) {
  if (se_dh_msg3_ != &::google::protobuf::internal::kEmptyString) {
    delete se_dh_msg3_;
  }
  if (se_dh_msg3) {
    set_has_se_dh_msg3();
    se_dh_msg3_ = se_dh_msg3;
  } else {
    clear_has_se_dh_msg3();
    se_dh_msg3_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Response_CloseSessionResponse

// required uint32 errorCode = 1 [default = 1];
inline bool Response_CloseSessionResponse::has_errorcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response_CloseSessionResponse::set_has_errorcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response_CloseSessionResponse::clear_has_errorcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response_CloseSessionResponse::clear_errorcode() {
  errorcode_ = 1u;
  clear_has_errorcode();
}
inline ::google::protobuf::uint32 Response_CloseSessionResponse::errorcode() const {
  return errorcode_;
}
inline void Response_CloseSessionResponse::set_errorcode(::google::protobuf::uint32 value) {
  set_has_errorcode();
  errorcode_ = value;
}

// -------------------------------------------------------------------

// Response_GetPsCapResponse

// required uint32 errorCode = 1 [default = 1];
inline bool Response_GetPsCapResponse::has_errorcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response_GetPsCapResponse::set_has_errorcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response_GetPsCapResponse::clear_has_errorcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response_GetPsCapResponse::clear_errorcode() {
  errorcode_ = 1u;
  clear_has_errorcode();
}
inline ::google::protobuf::uint32 Response_GetPsCapResponse::errorcode() const {
  return errorcode_;
}
inline void Response_GetPsCapResponse::set_errorcode(::google::protobuf::uint32 value) {
  set_has_errorcode();
  errorcode_ = value;
}

// optional uint64 ps_cap = 2;
inline bool Response_GetPsCapResponse::has_ps_cap() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response_GetPsCapResponse::set_has_ps_cap() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response_GetPsCapResponse::clear_has_ps_cap() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Response_GetPsCapResponse::clear_ps_cap() {
  ps_cap_ = GOOGLE_ULONGLONG(0);
  clear_has_ps_cap();
}
inline ::google::protobuf::uint64 Response_GetPsCapResponse::ps_cap() const {
  return ps_cap_;
}
inline void Response_GetPsCapResponse::set_ps_cap(::google::protobuf::uint64 value) {
  set_has_ps_cap();
  ps_cap_ = value;
}

// -------------------------------------------------------------------

// Response_GetWhiteListSizeResponse

// required uint32 errorCode = 1 [default = 1];
inline bool Response_GetWhiteListSizeResponse::has_errorcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response_GetWhiteListSizeResponse::set_has_errorcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response_GetWhiteListSizeResponse::clear_has_errorcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response_GetWhiteListSizeResponse::clear_errorcode() {
  errorcode_ = 1u;
  clear_has_errorcode();
}
inline ::google::protobuf::uint32 Response_GetWhiteListSizeResponse::errorcode() const {
  return errorcode_;
}
inline void Response_GetWhiteListSizeResponse::set_errorcode(::google::protobuf::uint32 value) {
  set_has_errorcode();
  errorcode_ = value;
}

// optional uint32 white_list_size = 2;
inline bool Response_GetWhiteListSizeResponse::has_white_list_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response_GetWhiteListSizeResponse::set_has_white_list_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response_GetWhiteListSizeResponse::clear_has_white_list_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Response_GetWhiteListSizeResponse::clear_white_list_size() {
  white_list_size_ = 0u;
  clear_has_white_list_size();
}
inline ::google::protobuf::uint32 Response_GetWhiteListSizeResponse::white_list_size() const {
  return white_list_size_;
}
inline void Response_GetWhiteListSizeResponse::set_white_list_size(::google::protobuf::uint32 value) {
  set_has_white_list_size();
  white_list_size_ = value;
}

// -------------------------------------------------------------------

// Response_GetWhiteListResponse

// required uint32 errorCode = 1 [default = 1];
inline bool Response_GetWhiteListResponse::has_errorcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response_GetWhiteListResponse::set_has_errorcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response_GetWhiteListResponse::clear_has_errorcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response_GetWhiteListResponse::clear_errorcode() {
  errorcode_ = 1u;
  clear_has_errorcode();
}
inline ::google::protobuf::uint32 Response_GetWhiteListResponse::errorcode() const {
  return errorcode_;
}
inline void Response_GetWhiteListResponse::set_errorcode(::google::protobuf::uint32 value) {
  set_has_errorcode();
  errorcode_ = value;
}

// optional bytes white_list = 2;
inline bool Response_GetWhiteListResponse::has_white_list() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response_GetWhiteListResponse::set_has_white_list() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response_GetWhiteListResponse::clear_has_white_list() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Response_GetWhiteListResponse::clear_white_list() {
  if (white_list_ != &::google::protobuf::internal::kEmptyString) {
    white_list_->clear();
  }
  clear_has_white_list();
}
inline const ::std::string& Response_GetWhiteListResponse::white_list() const {
  return *white_list_;
}
inline void Response_GetWhiteListResponse::set_white_list(const ::std::string& value) {
  set_has_white_list();
  if (white_list_ == &::google::protobuf::internal::kEmptyString) {
    white_list_ = new ::std::string;
  }
  white_list_->assign(value);
}
inline void Response_GetWhiteListResponse::set_white_list(const char* value) {
  set_has_white_list();
  if (white_list_ == &::google::protobuf::internal::kEmptyString) {
    white_list_ = new ::std::string;
  }
  white_list_->assign(value);
}
inline void Response_GetWhiteListResponse::set_white_list(const void* value, size_t size) {
  set_has_white_list();
  if (white_list_ == &::google::protobuf::internal::kEmptyString) {
    white_list_ = new ::std::string;
  }
  white_list_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Response_GetWhiteListResponse::mutable_white_list() {
  set_has_white_list();
  if (white_list_ == &::google::protobuf::internal::kEmptyString) {
    white_list_ = new ::std::string;
  }
  return white_list_;
}
inline ::std::string* Response_GetWhiteListResponse::release_white_list() {
  clear_has_white_list();
  if (white_list_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = white_list_;
    white_list_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Response_GetWhiteListResponse::set_allocated_white_list(::std::string* white_list) {
  if (white_list_ != &::google::protobuf::internal::kEmptyString) {
    delete white_list_;
  }
  if (white_list) {
    set_has_white_list();
    white_list_ = white_list;
  } else {
    clear_has_white_list();
    white_list_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Response_SGXGetExtendedEpidGroupIdResponse

// required uint32 errorCode = 1 [default = 1];
inline bool Response_SGXGetExtendedEpidGroupIdResponse::has_errorcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response_SGXGetExtendedEpidGroupIdResponse::set_has_errorcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response_SGXGetExtendedEpidGroupIdResponse::clear_has_errorcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response_SGXGetExtendedEpidGroupIdResponse::clear_errorcode() {
  errorcode_ = 1u;
  clear_has_errorcode();
}
inline ::google::protobuf::uint32 Response_SGXGetExtendedEpidGroupIdResponse::errorcode() const {
  return errorcode_;
}
inline void Response_SGXGetExtendedEpidGroupIdResponse::set_errorcode(::google::protobuf::uint32 value) {
  set_has_errorcode();
  errorcode_ = value;
}

// optional uint32 x_group_id = 2;
inline bool Response_SGXGetExtendedEpidGroupIdResponse::has_x_group_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response_SGXGetExtendedEpidGroupIdResponse::set_has_x_group_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response_SGXGetExtendedEpidGroupIdResponse::clear_has_x_group_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Response_SGXGetExtendedEpidGroupIdResponse::clear_x_group_id() {
  x_group_id_ = 0u;
  clear_has_x_group_id();
}
inline ::google::protobuf::uint32 Response_SGXGetExtendedEpidGroupIdResponse::x_group_id() const {
  return x_group_id_;
}
inline void Response_SGXGetExtendedEpidGroupIdResponse::set_x_group_id(::google::protobuf::uint32 value) {
  set_has_x_group_id();
  x_group_id_ = value;
}

// -------------------------------------------------------------------

// Response_SGXSwitchExtendedEpidGroupResponse

// required uint32 errorCode = 1 [default = 1];
inline bool Response_SGXSwitchExtendedEpidGroupResponse::has_errorcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response_SGXSwitchExtendedEpidGroupResponse::set_has_errorcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response_SGXSwitchExtendedEpidGroupResponse::clear_has_errorcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response_SGXSwitchExtendedEpidGroupResponse::clear_errorcode() {
  errorcode_ = 1u;
  clear_has_errorcode();
}
inline ::google::protobuf::uint32 Response_SGXSwitchExtendedEpidGroupResponse::errorcode() const {
  return errorcode_;
}
inline void Response_SGXSwitchExtendedEpidGroupResponse::set_errorcode(::google::protobuf::uint32 value) {
  set_has_errorcode();
  errorcode_ = value;
}

// -------------------------------------------------------------------

// Response

// optional .aesm.message.Response.InitQuoteResponse initQuoteRes = 1;
inline bool Response::has_initquoteres() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response::set_has_initquoteres() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response::clear_has_initquoteres() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response::clear_initquoteres() {
  if (initquoteres_ != NULL) initquoteres_->::aesm::message::Response_InitQuoteResponse::Clear();
  clear_has_initquoteres();
}
inline const ::aesm::message::Response_InitQuoteResponse& Response::initquoteres() const {
  return initquoteres_ != NULL ? *initquoteres_ : *default_instance_->initquoteres_;
}
inline ::aesm::message::Response_InitQuoteResponse* Response::mutable_initquoteres() {
  set_has_initquoteres();
  if (initquoteres_ == NULL) initquoteres_ = new ::aesm::message::Response_InitQuoteResponse;
  return initquoteres_;
}
inline ::aesm::message::Response_InitQuoteResponse* Response::release_initquoteres() {
  clear_has_initquoteres();
  ::aesm::message::Response_InitQuoteResponse* temp = initquoteres_;
  initquoteres_ = NULL;
  return temp;
}
inline void Response::set_allocated_initquoteres(::aesm::message::Response_InitQuoteResponse* initquoteres) {
  delete initquoteres_;
  initquoteres_ = initquoteres;
  if (initquoteres) {
    set_has_initquoteres();
  } else {
    clear_has_initquoteres();
  }
}

// optional .aesm.message.Response.GetQuoteResponse getQuoteRes = 2;
inline bool Response::has_getquoteres() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response::set_has_getquoteres() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response::clear_has_getquoteres() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Response::clear_getquoteres() {
  if (getquoteres_ != NULL) getquoteres_->::aesm::message::Response_GetQuoteResponse::Clear();
  clear_has_getquoteres();
}
inline const ::aesm::message::Response_GetQuoteResponse& Response::getquoteres() const {
  return getquoteres_ != NULL ? *getquoteres_ : *default_instance_->getquoteres_;
}
inline ::aesm::message::Response_GetQuoteResponse* Response::mutable_getquoteres() {
  set_has_getquoteres();
  if (getquoteres_ == NULL) getquoteres_ = new ::aesm::message::Response_GetQuoteResponse;
  return getquoteres_;
}
inline ::aesm::message::Response_GetQuoteResponse* Response::release_getquoteres() {
  clear_has_getquoteres();
  ::aesm::message::Response_GetQuoteResponse* temp = getquoteres_;
  getquoteres_ = NULL;
  return temp;
}
inline void Response::set_allocated_getquoteres(::aesm::message::Response_GetQuoteResponse* getquoteres) {
  delete getquoteres_;
  getquoteres_ = getquoteres;
  if (getquoteres) {
    set_has_getquoteres();
  } else {
    clear_has_getquoteres();
  }
}

// optional .aesm.message.Response.GetLaunchTokenResponse getLicTokenRes = 3;
inline bool Response::has_getlictokenres() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Response::set_has_getlictokenres() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Response::clear_has_getlictokenres() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Response::clear_getlictokenres() {
  if (getlictokenres_ != NULL) getlictokenres_->::aesm::message::Response_GetLaunchTokenResponse::Clear();
  clear_has_getlictokenres();
}
inline const ::aesm::message::Response_GetLaunchTokenResponse& Response::getlictokenres() const {
  return getlictokenres_ != NULL ? *getlictokenres_ : *default_instance_->getlictokenres_;
}
inline ::aesm::message::Response_GetLaunchTokenResponse* Response::mutable_getlictokenres() {
  set_has_getlictokenres();
  if (getlictokenres_ == NULL) getlictokenres_ = new ::aesm::message::Response_GetLaunchTokenResponse;
  return getlictokenres_;
}
inline ::aesm::message::Response_GetLaunchTokenResponse* Response::release_getlictokenres() {
  clear_has_getlictokenres();
  ::aesm::message::Response_GetLaunchTokenResponse* temp = getlictokenres_;
  getlictokenres_ = NULL;
  return temp;
}
inline void Response::set_allocated_getlictokenres(::aesm::message::Response_GetLaunchTokenResponse* getlictokenres) {
  delete getlictokenres_;
  getlictokenres_ = getlictokenres;
  if (getlictokenres) {
    set_has_getlictokenres();
  } else {
    clear_has_getlictokenres();
  }
}

// optional .aesm.message.Response.ReportAttestationErrorResponse reportErrRes = 4;
inline bool Response::has_reporterrres() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Response::set_has_reporterrres() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Response::clear_has_reporterrres() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Response::clear_reporterrres() {
  if (reporterrres_ != NULL) reporterrres_->::aesm::message::Response_ReportAttestationErrorResponse::Clear();
  clear_has_reporterrres();
}
inline const ::aesm::message::Response_ReportAttestationErrorResponse& Response::reporterrres() const {
  return reporterrres_ != NULL ? *reporterrres_ : *default_instance_->reporterrres_;
}
inline ::aesm::message::Response_ReportAttestationErrorResponse* Response::mutable_reporterrres() {
  set_has_reporterrres();
  if (reporterrres_ == NULL) reporterrres_ = new ::aesm::message::Response_ReportAttestationErrorResponse;
  return reporterrres_;
}
inline ::aesm::message::Response_ReportAttestationErrorResponse* Response::release_reporterrres() {
  clear_has_reporterrres();
  ::aesm::message::Response_ReportAttestationErrorResponse* temp = reporterrres_;
  reporterrres_ = NULL;
  return temp;
}
inline void Response::set_allocated_reporterrres(::aesm::message::Response_ReportAttestationErrorResponse* reporterrres) {
  delete reporterrres_;
  reporterrres_ = reporterrres;
  if (reporterrres) {
    set_has_reporterrres();
  } else {
    clear_has_reporterrres();
  }
}

// optional .aesm.message.Response.CreateSessionResponse createSessionRes = 5;
inline bool Response::has_createsessionres() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Response::set_has_createsessionres() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Response::clear_has_createsessionres() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Response::clear_createsessionres() {
  if (createsessionres_ != NULL) createsessionres_->::aesm::message::Response_CreateSessionResponse::Clear();
  clear_has_createsessionres();
}
inline const ::aesm::message::Response_CreateSessionResponse& Response::createsessionres() const {
  return createsessionres_ != NULL ? *createsessionres_ : *default_instance_->createsessionres_;
}
inline ::aesm::message::Response_CreateSessionResponse* Response::mutable_createsessionres() {
  set_has_createsessionres();
  if (createsessionres_ == NULL) createsessionres_ = new ::aesm::message::Response_CreateSessionResponse;
  return createsessionres_;
}
inline ::aesm::message::Response_CreateSessionResponse* Response::release_createsessionres() {
  clear_has_createsessionres();
  ::aesm::message::Response_CreateSessionResponse* temp = createsessionres_;
  createsessionres_ = NULL;
  return temp;
}
inline void Response::set_allocated_createsessionres(::aesm::message::Response_CreateSessionResponse* createsessionres) {
  delete createsessionres_;
  createsessionres_ = createsessionres;
  if (createsessionres) {
    set_has_createsessionres();
  } else {
    clear_has_createsessionres();
  }
}

// optional .aesm.message.Response.InvokeServiceResponse invokeServiceRes = 6;
inline bool Response::has_invokeserviceres() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Response::set_has_invokeserviceres() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Response::clear_has_invokeserviceres() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Response::clear_invokeserviceres() {
  if (invokeserviceres_ != NULL) invokeserviceres_->::aesm::message::Response_InvokeServiceResponse::Clear();
  clear_has_invokeserviceres();
}
inline const ::aesm::message::Response_InvokeServiceResponse& Response::invokeserviceres() const {
  return invokeserviceres_ != NULL ? *invokeserviceres_ : *default_instance_->invokeserviceres_;
}
inline ::aesm::message::Response_InvokeServiceResponse* Response::mutable_invokeserviceres() {
  set_has_invokeserviceres();
  if (invokeserviceres_ == NULL) invokeserviceres_ = new ::aesm::message::Response_InvokeServiceResponse;
  return invokeserviceres_;
}
inline ::aesm::message::Response_InvokeServiceResponse* Response::release_invokeserviceres() {
  clear_has_invokeserviceres();
  ::aesm::message::Response_InvokeServiceResponse* temp = invokeserviceres_;
  invokeserviceres_ = NULL;
  return temp;
}
inline void Response::set_allocated_invokeserviceres(::aesm::message::Response_InvokeServiceResponse* invokeserviceres) {
  delete invokeserviceres_;
  invokeserviceres_ = invokeserviceres;
  if (invokeserviceres) {
    set_has_invokeserviceres();
  } else {
    clear_has_invokeserviceres();
  }
}

// optional .aesm.message.Response.ExchangeReportResponse exchangeReportRes = 7;
inline bool Response::has_exchangereportres() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Response::set_has_exchangereportres() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Response::clear_has_exchangereportres() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Response::clear_exchangereportres() {
  if (exchangereportres_ != NULL) exchangereportres_->::aesm::message::Response_ExchangeReportResponse::Clear();
  clear_has_exchangereportres();
}
inline const ::aesm::message::Response_ExchangeReportResponse& Response::exchangereportres() const {
  return exchangereportres_ != NULL ? *exchangereportres_ : *default_instance_->exchangereportres_;
}
inline ::aesm::message::Response_ExchangeReportResponse* Response::mutable_exchangereportres() {
  set_has_exchangereportres();
  if (exchangereportres_ == NULL) exchangereportres_ = new ::aesm::message::Response_ExchangeReportResponse;
  return exchangereportres_;
}
inline ::aesm::message::Response_ExchangeReportResponse* Response::release_exchangereportres() {
  clear_has_exchangereportres();
  ::aesm::message::Response_ExchangeReportResponse* temp = exchangereportres_;
  exchangereportres_ = NULL;
  return temp;
}
inline void Response::set_allocated_exchangereportres(::aesm::message::Response_ExchangeReportResponse* exchangereportres) {
  delete exchangereportres_;
  exchangereportres_ = exchangereportres;
  if (exchangereportres) {
    set_has_exchangereportres();
  } else {
    clear_has_exchangereportres();
  }
}

// optional .aesm.message.Response.CloseSessionResponse closeSessionRes = 8;
inline bool Response::has_closesessionres() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Response::set_has_closesessionres() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Response::clear_has_closesessionres() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Response::clear_closesessionres() {
  if (closesessionres_ != NULL) closesessionres_->::aesm::message::Response_CloseSessionResponse::Clear();
  clear_has_closesessionres();
}
inline const ::aesm::message::Response_CloseSessionResponse& Response::closesessionres() const {
  return closesessionres_ != NULL ? *closesessionres_ : *default_instance_->closesessionres_;
}
inline ::aesm::message::Response_CloseSessionResponse* Response::mutable_closesessionres() {
  set_has_closesessionres();
  if (closesessionres_ == NULL) closesessionres_ = new ::aesm::message::Response_CloseSessionResponse;
  return closesessionres_;
}
inline ::aesm::message::Response_CloseSessionResponse* Response::release_closesessionres() {
  clear_has_closesessionres();
  ::aesm::message::Response_CloseSessionResponse* temp = closesessionres_;
  closesessionres_ = NULL;
  return temp;
}
inline void Response::set_allocated_closesessionres(::aesm::message::Response_CloseSessionResponse* closesessionres) {
  delete closesessionres_;
  closesessionres_ = closesessionres;
  if (closesessionres) {
    set_has_closesessionres();
  } else {
    clear_has_closesessionres();
  }
}

// optional .aesm.message.Response.GetPsCapResponse getPsCapRes = 9;
inline bool Response::has_getpscapres() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Response::set_has_getpscapres() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Response::clear_has_getpscapres() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Response::clear_getpscapres() {
  if (getpscapres_ != NULL) getpscapres_->::aesm::message::Response_GetPsCapResponse::Clear();
  clear_has_getpscapres();
}
inline const ::aesm::message::Response_GetPsCapResponse& Response::getpscapres() const {
  return getpscapres_ != NULL ? *getpscapres_ : *default_instance_->getpscapres_;
}
inline ::aesm::message::Response_GetPsCapResponse* Response::mutable_getpscapres() {
  set_has_getpscapres();
  if (getpscapres_ == NULL) getpscapres_ = new ::aesm::message::Response_GetPsCapResponse;
  return getpscapres_;
}
inline ::aesm::message::Response_GetPsCapResponse* Response::release_getpscapres() {
  clear_has_getpscapres();
  ::aesm::message::Response_GetPsCapResponse* temp = getpscapres_;
  getpscapres_ = NULL;
  return temp;
}
inline void Response::set_allocated_getpscapres(::aesm::message::Response_GetPsCapResponse* getpscapres) {
  delete getpscapres_;
  getpscapres_ = getpscapres;
  if (getpscapres) {
    set_has_getpscapres();
  } else {
    clear_has_getpscapres();
  }
}

// optional .aesm.message.Response.GetWhiteListSizeResponse getWhiteListSizeRes = 10;
inline bool Response::has_getwhitelistsizeres() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Response::set_has_getwhitelistsizeres() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Response::clear_has_getwhitelistsizeres() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Response::clear_getwhitelistsizeres() {
  if (getwhitelistsizeres_ != NULL) getwhitelistsizeres_->::aesm::message::Response_GetWhiteListSizeResponse::Clear();
  clear_has_getwhitelistsizeres();
}
inline const ::aesm::message::Response_GetWhiteListSizeResponse& Response::getwhitelistsizeres() const {
  return getwhitelistsizeres_ != NULL ? *getwhitelistsizeres_ : *default_instance_->getwhitelistsizeres_;
}
inline ::aesm::message::Response_GetWhiteListSizeResponse* Response::mutable_getwhitelistsizeres() {
  set_has_getwhitelistsizeres();
  if (getwhitelistsizeres_ == NULL) getwhitelistsizeres_ = new ::aesm::message::Response_GetWhiteListSizeResponse;
  return getwhitelistsizeres_;
}
inline ::aesm::message::Response_GetWhiteListSizeResponse* Response::release_getwhitelistsizeres() {
  clear_has_getwhitelistsizeres();
  ::aesm::message::Response_GetWhiteListSizeResponse* temp = getwhitelistsizeres_;
  getwhitelistsizeres_ = NULL;
  return temp;
}
inline void Response::set_allocated_getwhitelistsizeres(::aesm::message::Response_GetWhiteListSizeResponse* getwhitelistsizeres) {
  delete getwhitelistsizeres_;
  getwhitelistsizeres_ = getwhitelistsizeres;
  if (getwhitelistsizeres) {
    set_has_getwhitelistsizeres();
  } else {
    clear_has_getwhitelistsizeres();
  }
}

// optional .aesm.message.Response.GetWhiteListResponse getWhiteListRes = 11;
inline bool Response::has_getwhitelistres() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Response::set_has_getwhitelistres() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Response::clear_has_getwhitelistres() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Response::clear_getwhitelistres() {
  if (getwhitelistres_ != NULL) getwhitelistres_->::aesm::message::Response_GetWhiteListResponse::Clear();
  clear_has_getwhitelistres();
}
inline const ::aesm::message::Response_GetWhiteListResponse& Response::getwhitelistres() const {
  return getwhitelistres_ != NULL ? *getwhitelistres_ : *default_instance_->getwhitelistres_;
}
inline ::aesm::message::Response_GetWhiteListResponse* Response::mutable_getwhitelistres() {
  set_has_getwhitelistres();
  if (getwhitelistres_ == NULL) getwhitelistres_ = new ::aesm::message::Response_GetWhiteListResponse;
  return getwhitelistres_;
}
inline ::aesm::message::Response_GetWhiteListResponse* Response::release_getwhitelistres() {
  clear_has_getwhitelistres();
  ::aesm::message::Response_GetWhiteListResponse* temp = getwhitelistres_;
  getwhitelistres_ = NULL;
  return temp;
}
inline void Response::set_allocated_getwhitelistres(::aesm::message::Response_GetWhiteListResponse* getwhitelistres) {
  delete getwhitelistres_;
  getwhitelistres_ = getwhitelistres;
  if (getwhitelistres) {
    set_has_getwhitelistres();
  } else {
    clear_has_getwhitelistres();
  }
}

// optional .aesm.message.Response.SGXGetExtendedEpidGroupIdResponse sgxGetExtendedEpidGroupIdRes = 12;
inline bool Response::has_sgxgetextendedepidgroupidres() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Response::set_has_sgxgetextendedepidgroupidres() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Response::clear_has_sgxgetextendedepidgroupidres() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Response::clear_sgxgetextendedepidgroupidres() {
  if (sgxgetextendedepidgroupidres_ != NULL) sgxgetextendedepidgroupidres_->::aesm::message::Response_SGXGetExtendedEpidGroupIdResponse::Clear();
  clear_has_sgxgetextendedepidgroupidres();
}
inline const ::aesm::message::Response_SGXGetExtendedEpidGroupIdResponse& Response::sgxgetextendedepidgroupidres() const {
  return sgxgetextendedepidgroupidres_ != NULL ? *sgxgetextendedepidgroupidres_ : *default_instance_->sgxgetextendedepidgroupidres_;
}
inline ::aesm::message::Response_SGXGetExtendedEpidGroupIdResponse* Response::mutable_sgxgetextendedepidgroupidres() {
  set_has_sgxgetextendedepidgroupidres();
  if (sgxgetextendedepidgroupidres_ == NULL) sgxgetextendedepidgroupidres_ = new ::aesm::message::Response_SGXGetExtendedEpidGroupIdResponse;
  return sgxgetextendedepidgroupidres_;
}
inline ::aesm::message::Response_SGXGetExtendedEpidGroupIdResponse* Response::release_sgxgetextendedepidgroupidres() {
  clear_has_sgxgetextendedepidgroupidres();
  ::aesm::message::Response_SGXGetExtendedEpidGroupIdResponse* temp = sgxgetextendedepidgroupidres_;
  sgxgetextendedepidgroupidres_ = NULL;
  return temp;
}
inline void Response::set_allocated_sgxgetextendedepidgroupidres(::aesm::message::Response_SGXGetExtendedEpidGroupIdResponse* sgxgetextendedepidgroupidres) {
  delete sgxgetextendedepidgroupidres_;
  sgxgetextendedepidgroupidres_ = sgxgetextendedepidgroupidres;
  if (sgxgetextendedepidgroupidres) {
    set_has_sgxgetextendedepidgroupidres();
  } else {
    clear_has_sgxgetextendedepidgroupidres();
  }
}

// optional .aesm.message.Response.SGXSwitchExtendedEpidGroupResponse sgxSwitchExtendedEpidGroupRes = 13;
inline bool Response::has_sgxswitchextendedepidgroupres() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Response::set_has_sgxswitchextendedepidgroupres() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Response::clear_has_sgxswitchextendedepidgroupres() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Response::clear_sgxswitchextendedepidgroupres() {
  if (sgxswitchextendedepidgroupres_ != NULL) sgxswitchextendedepidgroupres_->::aesm::message::Response_SGXSwitchExtendedEpidGroupResponse::Clear();
  clear_has_sgxswitchextendedepidgroupres();
}
inline const ::aesm::message::Response_SGXSwitchExtendedEpidGroupResponse& Response::sgxswitchextendedepidgroupres() const {
  return sgxswitchextendedepidgroupres_ != NULL ? *sgxswitchextendedepidgroupres_ : *default_instance_->sgxswitchextendedepidgroupres_;
}
inline ::aesm::message::Response_SGXSwitchExtendedEpidGroupResponse* Response::mutable_sgxswitchextendedepidgroupres() {
  set_has_sgxswitchextendedepidgroupres();
  if (sgxswitchextendedepidgroupres_ == NULL) sgxswitchextendedepidgroupres_ = new ::aesm::message::Response_SGXSwitchExtendedEpidGroupResponse;
  return sgxswitchextendedepidgroupres_;
}
inline ::aesm::message::Response_SGXSwitchExtendedEpidGroupResponse* Response::release_sgxswitchextendedepidgroupres() {
  clear_has_sgxswitchextendedepidgroupres();
  ::aesm::message::Response_SGXSwitchExtendedEpidGroupResponse* temp = sgxswitchextendedepidgroupres_;
  sgxswitchextendedepidgroupres_ = NULL;
  return temp;
}
inline void Response::set_allocated_sgxswitchextendedepidgroupres(::aesm::message::Response_SGXSwitchExtendedEpidGroupResponse* sgxswitchextendedepidgroupres) {
  delete sgxswitchextendedepidgroupres_;
  sgxswitchextendedepidgroupres_ = sgxswitchextendedepidgroupres;
  if (sgxswitchextendedepidgroupres) {
    set_has_sgxswitchextendedepidgroupres();
  } else {
    clear_has_sgxswitchextendedepidgroupres();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace message
}  // namespace aesm

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_messages_2eproto__INCLUDED
